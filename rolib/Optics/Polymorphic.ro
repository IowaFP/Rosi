import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Data.Functor , Control.Monad , Control.Monad.List

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

--------------------------------------------------------------------------------
-- Polymorphic adapters


--------------------------------------------------------------------------------
-- Polymorphic lenses

type Lens : * -> * -> * -> * -> *
type Lens =  \ a b s t. Pi { 'get := s -> a , 'put := s -> b -> t }

get = sel #'get 
put = sel #'put

modify : forall a b s t. Lens a b s t -> (a -> b) -> s -> t
modify = \ l f s. put l s (f (get l s))

-- -- Each label forms a lens 
lens : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
       #l -> Lens a b (Pi x) (Pi y)
lens = \ l. (#'get := sel l , #'put := \ s b. (l := b) ++ prj s)

-- Bijective lenses are lenses that ignore the source during a putback
-- (Bijective lenses are equivalent to adapters.)
bijective : forall a b s t : *. (s -> a) -> (b -> t) -> Lens a b s t 
bijective = \ get put. (#'get := get , #'put := \ s. put)

-- -- lenses may be composed
comp : forall a a' b b' s t : *. Lens a b s t -> Lens a' b'  a b -> Lens a' b' s t
comp = \ x y. (#'get :=  o (get y) (get x) , #'put := \ s b'. put x s (put y (get x s) b'))


--------------------------------------------------------------------------------
-- Prisms

type Prism : * -> * -> * -> * -> * 
type Prism = \ a b s t. Pi { 'get := s -> Either a t , 'put := b -> t }

-- each label creates a prism
prism : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
        #l -> Prism a b (Sigma x) (Sigma y)
prism = \ l. (#'get := case l Left | (o Right inj) , #'put := con l)

-- -- Prisms may be composed
compPrism : forall a a' b b' s t : *. Prism a b s t -> Prism a' b'  a b -> Prism a' b' s t
compPrism = \ x y. (#'get := sorry , #'put := o (put x) (put y) )

-- get x : s -> Either a t 
-- get y : a -> Either a' b 
-- Need :  s -> Either a' t 

