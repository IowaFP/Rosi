import Ro.Base , Ro.Show , Data.Nat , Data.Tuple , Data.List
--------------------------------------------------------------------------------
-- Reproducing results from Leijen's First Class Labels for Extensible Rows
--   - https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/fclabels.pdf?msockid=204eae218676650527f9bd2e871464e2

--------------------------------------------------------------------------------
--
-- to run (from home dir):
--   - cabal run Rosi -- -i rolib -i examples Leijen
-- to evaluate terms, e.g., foo:
--   - cabal run Rosi -- -i rolib -i examples Leijen -e foo

--------------------------------------------------------------------------------
-- §3 First Class labels
--
-- We can recover the primitives of Leijen's calculus:
--   - record selection
--   - record restriction

-- Selection (from Ro.Base)
sel' : forall l : L, t : *, z : R[*]. {l := t} < z => Pi z -> #l -> t
sel' = sel

-- (multi-field) restriction
restrict : forall x y : R[*]. x < y => Pi y -> Pi (y - x)
restrict = \ d. prj d

-- single-field restriction
remove : forall l : L, t : *, z : R[*]. {l := t} < z => Pi z -> #l -> Pi (z - {l := t})
remove = \ d l. prj d

--------------------------------------------------------------------------------
-- §3.1 Label constants

zeroPair : forall l m : L , z : R[ * ]. {l := Nat} + {m := Nat} ~ z =>  #l -> #m -> Pi z
zeroPair = \ l m. (l := 0) ++ (m := 0)

origin : Pi {'x := Nat , 'y := Nat}
origin = zeroPair #'x #'y

--------------------------------------------------------------------------------
-- §4 Expressiveness of first-class labels

-- Leijen defines any = ⊥, which we needn't do.
-- Ultimately this is justified as labels translate to the unit type.
any : forall l : L. #l
any = /\ l. #l

-- §4.1 Intersection types
intBool : forall l : L, t : *.
          {l := t} < {'n := Nat , 'b := Bool} => t
intBool = /\ l t. sel (#'n := 1 , #'b := True) (any [ l ])

-- The magic is sort of lost with explicit type parameters---
-- of course, a first-class label is often just a type annotation
-- in disguise.
n : Nat
n = ite (intBool ['b] [Bool]) (succ (intBool ['n] [Nat])) 0

-- §4.2 Overloading
type Plus : R[ * ]
type Plus = { 'nat := Nat -> Nat -> Nat ,
              'bool := Bool -> Bool -> Bool }

plusRec : Pi Plus
plusRec = (#'nat := add , #'bool := or )

plus : forall l : L , t : *. {l := t } < Plus => t
plus = /\ l. sel plusRec (any [ l ])

-- it'd be a lot cooler if these type applications could be inferred
ok : Pair Nat Bool
ok = pair (plus ['nat] [Nat -> Nat -> Nat] 1 2) (plus ['bool] [Bool -> Bool -> Bool] True False)

-- "In conventional closed-world overloading, each overloaded definition must be sufficientlly
-- monomorphic to resove the overloading statically, but this is not necessary in our system."
nary : forall b c : *. Pi { 'one := b -> List b , 'two := c -> c -> List c }
nary = (#'one := \ x. sing x , #'two := \ x y. cons x (sing y))

nlist : forall l : L , a b c : *. {l := a} < { 'one := b -> List b , 'two := c -> c -> List c } => a
nlist = /\ l a b c. sel (nary [b] [c]) (any [l])

-- §4.3 Type case
-- This is another example where the magic seems to be simply omitting type application annotations.
-- That is, the magic is to do with type inference and not the calculus.
-- Moreover, the behavior of this function is ambiguous if it were to truly be used
-- as type casing, as (a -> b) could occur multiple types in r.
typecase : forall l : L, r : R[*], a b : *. {l := a -> b} < r => a -> Pi r -> b
typecase = /\ l. \ x d. (sel d #l) x

-- §4.3 Type selective functions
-- (Skipping; more of the same as above.)

-- §5 First-class patterns
-- Here Rosi really shines, as Leijen must define a primitive "case" that reflects
-- a record of handlers into a variant eliminator. But we have already derived
-- this in previous work.

sum : List Nat -> Nat
sum = fix (\ sum.
    (reflect (#'Nil := \ r. 0 ,
              #'Cons := \ r. add (fst r) (sum (snd r)))))









