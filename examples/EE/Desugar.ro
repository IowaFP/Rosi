import Ro.Base, Ro.Xr, Data.Functor, Data.List, Data.Nat, Data.Tuple, EE.Types

-------------------------------------------------------------------------------
-- Desugaring
--
-- Next challenge is to implement desugaring. The key point here is to highlight
-- label-generic programming.
--
-- As an example, we'll implement Booleans as functions. We're relying on this
-- being an untyped language, so we don't have to account for polymorphism.

app : forall z. LamF < z => Mu (Sigma z) -> Mu (Sigma z) -> Mu (Sigma z)
app = \f e. con #'App (pair f e)

desugarB : forall z.
           LamF < z =>
           Xh BoolF (\w. Mu (Sigma z))
desugarB = \exp rec.
            match exp
            (case #'BConst
               ( case #'True (\u. con #'Lam (con #'Lam (con #'Var one)))
               | case #'False (\u. con #'Lam (con #'Lam (con #'Var zero)))
               )
            | case #'If (\t. app (app (rec (fst t)) (rec (snd t))) (rec (thd t)))
            )

-------------------------------------------------------------------------------
-- Identity traversal

ext : forall z : R[* -> *]. Pi (Functor z) -> Xh z (\ w. (Mu (Sigma z)))
ext = \ d v rec. fmapS d rec v

-- TODO: Why is the result in terms of z, not w? The latter would require an
-- inj, but seems like the more correct thing to do...?

desugar : forall y. BoolF < y, LamF < y - BoolF =>
          Pi (Functor (y - BoolF)) -> Xh y (\ w. (Mu (Sigma (y - BoolF))))
desugar = \d. desugarB | ext d

xpNott : Mu (Sigma LBF)
xpNott = con #'Lam (con #'If (triple (con #'Var zero) (con #'BConst False) (con #'BConst True)))

desNott : Mu (Sigma LamF)
desNott = histo (desugar functorLam) xpNott