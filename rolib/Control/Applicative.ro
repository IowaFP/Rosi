import Data.Functor , Control.Monoid

type Applicative : (* -> *) -> *
type Applicative = \f. Pi { 'Functor := Functor f,
                            'pure := forall a. a -> f a,
                            'ap := forall a b. f (a -> b) -> f a -> f b }

applicativeFunctor : forall z : R[* -> *]. Pi (Applicative z) -> Pi (Functor z)
applicativeFunctor = mapP #(Applicative) #(Functor) (\l d. sel d #'Functor)

--------------------------------------------------------------------------------
-- The identity and constant functor 

applicativeId : Applicative Id
applicativeId = (#'Functor := /\ a b. functorId , 
                 #'pure := /\ a. id , 
                 #'ap := /\ a b. \ f. f)

-- as GHC defines it---Const m is applicative if m is a monoid.
applicativeConst : forall m. Monoid m -> Applicative (Const m)
applicativeConst = \ m. (#'Functor := /\ a b. functorConst ,
                    #'pure := /\ a. const (sel m #'empty) ,
                    #'ap := /\ a b. sel m #'append)

--------------------------------------------------------------------------------
-- The maybe functor 

pureMaybe : forall a. a -> Maybe a
pureMaybe = con #'Just

apMaybe : forall a b. Maybe (a -> b) -> Maybe a -> Maybe b
apMaybe = case #'Just (\g x. functorMaybe g x)
        | otherwise (const Nothing)

applicativeMaybe : Applicative Maybe
applicativeMaybe = (#'Functor := functorMaybe,
                    #'pure := pureMaybe,
                    #'ap := apMaybe)                    


