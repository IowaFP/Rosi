import Ro.Base

type Names : R[*] -> *
type Names = \z. Pi (Const String z)

type Show : * -> *
type Show = \t. t -> String

type ShowR : R[*] -> *
type ShowR = \z. Pi { 'names := Names z, 'shows := Pi (Show z) }

showRCat : forall x y z. x + y ~ z => ShowR x -> ShowR y -> ShowR z
showRCat = \r s. (#'names := sel r #'names ++ sel s #'names, #'shows := sel r #'shows ++ sel s #'shows)

showS : forall z. ShowR z -> Sigma z -> String
showS = \d. ana #(\X. X) (\l x. sel (sel d #'names) l ^ " := " ^ sel (sel d #'shows) l x)

showP : forall z. Fold z => ShowR z -> Pi z -> String
showP = \d r. "(" ^ fold (\l x. sel (sel d #'names) l ^ " := " ^ sel (sel d #'shows) l x) (\s t. s ^ ", " ^ t) "" r  ^ ")"

--

showUnit : Show Unit
showUnit = showP (#'names := tt, #'shows := tt)

showBool : Show Bool
showBool = \b . ite b "True" "False"

-------------------------------------------------------------------------------
-- A sneaky encoding of closed-world overloading, for demonstration.

show : forall l : L, t : *. Show {l := t} < Show { 'Unit := Unit , 'Bool := Bool } => Show t
show = /\ l t. sel (#'Unit := showUnit , #'Bool := showBool) (any [l])

ex : String 
ex = show ['Bool] [Bool] True