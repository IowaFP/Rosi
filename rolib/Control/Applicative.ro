import Data.Functor

type Applicative : (* -> *) -> *
type Applicative = \f. Pi { 'Functor := Functor f,
                            'pure := forall a. a -> f a,
                            'ap := forall a b. f (a -> b) -> f a -> f b }

applicativeFunctor : forall z : R[* -> *]. Pi (Applicative z) -> Pi (Functor z)
applicativeFunctor = mapP [Applicative] [Functor] (\l d. sel d #'Functor)

--

functorMaybe : Functor Maybe
functorMaybe = (\f. case #'Just (\x. Just (f x)) | case #'Nothing (const Nothing))

pureMaybe : forall a. a -> Maybe a
pureMaybe = con #'Just

apMaybe : forall a b. Maybe (a -> b) -> Maybe a -> Maybe b
apMaybe = case #'Just (\g x. functorMaybe g x)
        | otherwise (const Nothing)

applicativeMaybe : Applicative Maybe
applicativeMaybe = (#'Functor := functorMaybe,
                    #'pure := pureMaybe,
                    #'ap := apMaybe)


