-- Composition

o : forall t u v. (u -> v) -> (t -> u) -> t -> v
o = \ f g x. f (g x)

-- Convenience functions for records and variants

sel : forall l : L, t : *, z : R[*]. {l := t} < z => Pi z -> #l -> t
sel = \ r l. prj r / l

con : forall l : L, t : *, z : R[*]. {l := t} < z => #l -> t -> Sigma z
con = \l x. inj (l := x)

case : forall l t u. #l -> (t -> u) -> (l := t) -> u
case = \ l f x. f (x / l)

brnl : forall x z t. x < z => (Sigma x -> t) -> (Sigma z -> t) -> Sigma z -> t
brnl = \ f g. f ? (o g inj)

-- Base types

type Unit : *
type Unit = Pi {}

tt : Unit
tt = prj (#'x := (/\ a. \x. x))

type Bool : *
type Bool = Sigma { 'True := Unit, 'False := Unit }

True : Bool
True = con #'True tt

False : Bool
False = con #'False tt

-- Basic analysis / synthesis

reflect : forall z : R[*], t. Pi (z -> t) -> Sigma z -> t
reflect = \ d w. ana (\ l u. sel d l u) w

reify : forall z t. (Sigma z -> t) -> Pi (z -> t)
reify = /\ z t. \f. syn [\X. X -> t] (\l x. f (con l x))

type Eq : * -> *
type Eq = \t. t -> t -> Bool

eqS : forall z : R[*]. Pi (Eq z) -> Eq (Sigma z)
eqS = \ d v. ana (\ l y. (case l (\x. sel d l x y) ? (\x. False)) v)

-- eqP requires `fold`, which I'm ignoring for the time being...