sel : forall l : L, t : *, z : R[*]. {l := t} < z => Pi z -> #l -> t
sel = \ r l. prj r / l

reflect : forall z : R[*], t. Pi (z -> t) -> Sigma z -> t
reflect = \ d w. ana (\ l u. sel d l u) w

-- Need for mapS:

con : forall l : L, t : *, z : R[*]. {l := t} < z => #l -> t -> Sigma z
con = \l x. inj (l := x)

type Iter : ((* -> *) -> *) -> ((* -> *) -> *) -> R[* -> *] -> *
type Iter = \f g z. forall l u. {l := u} < z => #l -> f u -> g u

mapS : forall z : R[* -> *], f g : (* -> *) -> *.
       Iter f g z ->
       Sigma (f z) -> Sigma (g z)
mapS = /\ z f g. \ i v. ana [f] (\ l x. con l (i l x)) v

type Functor : (* -> *) -> *
type Functor = \f. forall a b. (a -> b) -> f a -> f b

fmapS : forall z : R[* -> *] . 
        Pi (Functor z) ->
        Functor (Sigma z)
fmapS = /\ z : R[* -> *]. 
        \ d : Pi (Functor z) . 
        /\ a b : *. 
        \ f : a -> b, w : Sigma z a . 
          mapS [z] [\ X : * -> *. X a] [\ X : * -> *. X b] (/\ l : L, u : * -> *. \ ll : #l, x : u a. (sel d ll : Functor u) f x) w

-- Can go directly via `ana` as well.

fmapS1 : forall z : R[* -> *] . 
         Pi (Functor z) ->
         Functor (Sigma z)
fmapS1 = /\ z : R[* -> *]. 
         \ d : Pi (Functor z) . 
         /\ a b : *. 
         \ f : a -> b, w : Sigma z a . 
         ana [\X : * -> *. X a] (/\ l u y1 z y2. \ ll : #l, x : u a. con ll ((sel d ll : Functor u) f x)) w

-- How many annotations can I leave out?

fmapS2 : forall z : R[* -> *] . Pi (Functor z) -> Functor (Sigma z) -- Why do I need the kind annotation on z??
fmapS2 = /\ z. \ d. /\ a b. \ f.
          mapS [z] [\ X. X a] [\ X. X b] (/\ l u. \ ll. (sel d ll : Functor u) f)

