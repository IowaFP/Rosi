import Ro.Base, Ro.Show , Data.Functor

type NatF : * -> *
type NatF = \n. Sigma { 'Zero := Unit, 'Succ := n}

fmapNatF : Functor NatF
fmapNatF = fmapS (#'Zero := /\ a b. \ f : a -> b,  u : Unit. u ,
                  #'Succ := /\ a b. \ f : a -> b. f)

type Nat : *
type Nat = Mu NatF

zero : Nat
zero = con #'Zero tt

succ : Nat -> Nat
succ = con #'Succ

--

decr : Nat -> Nat
decr = case #'Zero (const zero)
     | case #'Succ id

add : Nat -> Nat -> Nat
add = \m. fix (\add . case #'Zero (\u. m)
                    | case #'Succ (\nn. succ (add nn)))

mult : Nat -> Nat -> Nat
mult = \m. fix (\mult . case #'Zero (const zero)
                      | case #'Succ (\nn. add m (mult nn)))

monus : Nat -> Nat -> Nat
monus = fix (\ monus m n. (case #'Zero (\u. m) | case #'Succ (\nn. monus (decr m) nn)) n)

max : Nat -> Nat -> Nat
max = fix (\max m n.
  match m
  ( case #'Zero (const n)
  | case #'Succ (\m'.
    match n
    ( case #'Zero (const m)
    | case #'Succ (\n'. succ (max m' n'))))))

isZero : Nat -> Bool
isZero = case #'Zero (const True)
       | otherwise False

equal : Nat -> Nat -> Bool
equal = fix (\equal m n.
              match m
              ( case #'Zero (const (isZero n))
              | case #'Succ (\mm.
                match n
                ( case #'Zero (const False)
                | case #'Succ (\nn. equal mm nn)))))

--

showNat : Show Nat
showNat = fix (\showNat.
    ( case #'Zero (\ u. "Zero")
    | case #'Succ (\ n. "Succ (" ^ (showNat n) ^ ")" )))
--

one : Nat
one = succ zero

two : Nat
two = succ one

three : Nat
three = add one two

one0 : Nat
one0 = monus three two

three0 : Nat
three0 = max one0 three

three1 : Nat
three1 = max three one0

--

one' : Nat
one' = 1

three' : Nat
three' = add one' 2

three'1 : Nat
three'1 = max three' 1

--

one'' : String
one'' = showNat one'

three'' : String
three'' = showNat three'1