import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Data.Functor , Control.Monad , Control.Monad.List

--------------------------------------------------------------------------------
-- to run (from home dir):
--   - cabal run Rosi -- -i rolib Optics.Monomorphic
-- to evaluate terms, e.g., showBob:
--   - cabal run Rosi -- -i rolib Optics.Monomorphic -e showBob

--------------------------------------------------------------------------------
-- The interface for lenses
--
-- N.b. there are handful of equivalent representations one could use.
-- I follow the simplest and original, as proposed by Foster et al (2007).

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

type Lens : * -> * -> *
type Lens =  \ s t. Pi { 'get := s -> t , 'put := s -> t -> s }

get = sel #'get
put = sel #'put

modify : forall s t. Lens s t -> (t -> t) -> s -> s
modify = \ l f s. put l s (f (get l s))

-- Each label forms a lens
lens : forall l : L , t : * , z : R[*]. {l := t} < z => #l -> Lens (Pi z) t
lens = \ l. (#'get := sel l , #'put := \ s t. (l := t) ++ prj s)

-- lenses may be composed
comp : forall a b c : *. Lens a b -> Lens b c -> Lens a c
comp = \ x y. (#'get := (get y) . (get x) , #'put := \ a c. put x a (put y (get x a) c) )

-- Bijective lenses are lenses that ignore the source during a putback
bijective : forall s t : *. (s -> t) -> (t -> s) -> Lens s t
bijective = \ get put. (#'get := get , #'put := \ s. put)

{- --------------------------------------------------------------------------
# A bit on lens laws
--------------------

Lenses are a solution to the classic database "view update" problem,
in which one asks what changes may be made to a "view" that can be reflected back
to a source. This question has inspired the vast field of Bidirectional Programming today,
of which lenses, prisms, and optics are a leading, language-theoretic solution.
Ensuring that changes to a view accurately reflect back to the source amounts
to the following laws.

Defn. A *well-behaved* lens (l : Lens S T) observes the following two laws:
- (GetPut): A round-trip from source back to source incurs no changes:
            put l s (get l s) = s    for all s : S
- (PutGet): The put function captures all of the information in the abstract view:
            get l (put l s t) = t    for all s : S , t : T

Defn. A lens (l : Lens S T) is called *very well-behaved* if in addition it observes:
- (PutPut): performing two puts ignores the first put.
            put l (put l s t) t' = put s t'   for all s : S and t, t' : T

There are a number of other laws and variants of these laws depending on which
particular type of lens you are working with. Because Rosi is not dependently typed,
we cannot prove any law directly in the theory of Rosi. Just as with e.g. functor
laws in Haskell, these must be verified by hand.

----------------------------------------------------------------------------- -}



--------------------------------------------------------------------------------
-- Prisms

type Prism : * -> * -> *
type Prism = \ s t. Pi { 'get := s -> Maybe t , 'put := t -> s }

-- each label creates a prism
prism : forall l : L , t : * , z : R[*]. {l := t} < z => #l -> Prism (Sigma z) t
prism = \ l. (#'get := case l Just | otherwise Nothing , #'put := con l)

outPrism : forall f : * -> *. Prism (Mu f) (f (Mu f))
outPrism = (#'get := Just , #'put := id)

-- Prisms may be composed
compPrism : forall a b c : *. Prism a b -> Prism b c -> Prism a c
compPrism = \ l u. (#'get := composeKleisli monadMaybe (get u) (get l) , #'put := o (put l) (put u) )

rPrism : forall l : L , t : * -> * , z : R[ * -> *]. {l := t} < z => #l -> Prism (Mu (Sigma z)) (t (Mu (Sigma z)))
rPrism = \ l. compPrism outPrism (prism l)

--------------------------------------------------------------------------------
-- Adapters
-- Adapters specialize lenses and prisms
-- (Adapters are alternatively called Isos or bijective lenses.)

type Adapter : * -> * -> *
type Adapter = \ s t. Pi { 'from := s -> t , 'to := t -> s}

from = sel #'from
to   = sel #'to

adapterLens : forall s t. Adapter s t -> Lens s t
adapterLens = \ a. (#'get := from a , #'put := \ s t. to a t)

adapterPrism : forall s t. Adapter s t -> Prism s t
adapterPrism = \ a. (#'get := Just . (from a) , #'put := to a)


--------------------------------------------------------------------------------
-- Traversals
-- Traversal generalize lenses & prisms

type Traversal : * -> * -> *
type Traversal = \ s t. Pi {'toListOf := s -> List t , 'over := (t -> t) -> s -> s }

toListOf = sel #'toListOf
over = sel #'over

lensTraversal : forall s t. Lens s t -> Traversal s t
lensTraversal = \ l. (#'toListOf := sing . (get l)  , #'over := modify l)

prismTraversal : forall s t. Prism s t -> Traversal s t
prismTraversal = \ p.
  (#'toListOf := o (maybe nil sing) (get p)  ,
   #'over := \f s. match (get p s)
    ( case #'Nothing (const s)
    | case #'Just (put p . f)))

compTraversal : forall a b c. Traversal a b -> Traversal b c -> Traversal a c
compTraversal = \ x y.
  (#'toListOf := composeKleisli monadList (toListOf y) (toListOf x) ,
   #'over := \ f. over x (over y f))

inOrder : forall s t. Traversal s t -> Traversal (List s) t
inOrder = \ t.
  (#'toListOf := concat . (fmapList (toListOf t)) ,
   #'over := fmapList . (over t) )

{- -----------------------------------------------------------------------------
# The lattice of optics
-----------------------

      Traversals
      /       \
     /         \
   Lens        Prisms
     \         /
      \       /
       Adapters

-}

--------------------------------------------------------------------------------
-- Projection is a lens

-- We verify this lens is well-behaved:
--   - (GetPut). Let x + y ~ z and let zs : Pi z.
--        put projectLens zs (get projectLens zs)
--      = put projectLens zs ++ prj [x] [z] zs
--      = prj [x] [z] zs ++ prj [y] [z] zs
--      = zs
--   And
--   - (PutGet). Let x + y ~ z, xs : Pi x and zs : Pi z.
--        get projectLens (put projectLens zs xs)
--      = prj [x] [z] (put projectLens zs xs)
--      = prj [x] [z] (xs ++ prj [y] [z] zs)
--      = xs
--   as desired.
projectLens : forall x y : R[*]. x < y =>
              Lens (Pi y) (Pi x)
projectLens = /\ x y. (#'get := prj [x] [y] , #'put := \ zs xs. xs ++ prj [y - x] [y] zs)


--------------------------------------------------------------------------------
-- Concatenation is a lens
-- N.b. This would be a good candidate for asymmetric lenses w/ complements.
-- ((Pi y) is the complement.)
--
-- We verify this lens is well-behaved:
--   - (GetPut). Let p : Pair (Pi x) (Pi y)
--        put concatLens p (get concatLens p)
--      = put concatLens p (fst p ++ snd p)
--      = pair (prj [x] [z] (fst p ++ snd p)) (prj [y] [z] (fst p ++ snd p))
--      = pair (fst p) (snd p)
--      = p
--   And
--   - (PutGet). Let p : Pair (Pi x) (Pi y) and xs : Pi x
--        get concatLens (put concatLens xs p)
--      = get concatLens (pair (prj [x] [z] zs) (prj [y] [z] zs))
--      = fst (pair (prj [x] [z] zs) (prj [y] [z] zs)) ++ snd (pair (prj [x] [z] zs) (prj [y] [z] zs))
--      = (prj [x] [z] zs) ++ (prj [y] [z] zs)
--      = zs
concatLens : forall x y z : R[ * ]. x + y ~ z =>
             Lens (Pair (Pi x) (Pi y)) (Pi z)
concatLens = /\ x y z. (#'get := \ p.  fst p ++ snd p , #'put := \ p zs. pair (prj [x] [z] zs) (prj [y] [z] zs))

--------------------------------------------------------------------------------
-- Injection is a prism

injectPrism : forall x y : R[*]. x < y =>
              Prism (Sigma y) (Sigma x)
injectPrism = (#'get := Just | otherwise Nothing , #'put := inj)

--------------------------------------------------------------------------------
-- Branching is a prism

branchPrism : forall x y z : R[*]. x + y ~ z =>
              Prism (Sigma z) (Either (Sigma x) (Sigma y))
branchPrism = (#'get := Just . Left | Just . Right , #'put := case #'Left inj | case #'Right inj)

-- and a lens on eliminators
branchLens : forall x y z : R[*], t : *. x + y ~ z =>
              Lens (Pair (Sigma x -> t) (Sigma y -> t)) (Sigma z -> t)
branchLens = bijective (\ p. fst p | snd p) (\ t. pair (t . inj) (t . inj))

--------------------------------------------------------------------------------
-- A Pi to Sigma lens

toS : forall l : L , t : *, r : R[*]. {l := t} < r => #l -> Pi r -> Sigma r
toS = \ l d. inj (l := sel l d)

patch : forall r: R[*]. Pi r -> Sigma r -> Pi r
patch = \ d v. ana #(\X. X) (\ l u. prj d ++ (l := u)) v

RecToVarLens : forall l : L , t : *, r : R[*]. {l := t} < r => #l -> Lens (Pi r) (Sigma r)
RecToVarLens = \ l. (#'get := toS l , #'put := patch)

-- reify & reflect lenses;
-- tricky (if not impossible, for now) to verify the GetPut and PutGet laws.
rrLens : forall z : R[*], t : *. Lens (Pi (z -> t)) (Sigma z -> t)
rrLens = bijective reflect reify

