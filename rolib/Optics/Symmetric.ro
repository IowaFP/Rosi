import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Data.Functor , Control.Monad , Control.Monad.List

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

type Lens : * -> * -> * -> * 
type Lens = \ x y c. Pi { 
    'missing := c ,
    'putr := Pair x c -> Pair y c , 
    'putl := Pair y c -> Pair x c }

missing = sel #'missing
putr = sel #'putr 
putl = sel #'putl

-- laws:
--  - putr (x , c) = (y , c') -> putl (y , c') = (x , c')
--  - putl (y , c) = (x , c') -> putr (x , c') = (y , c')

projectLens : forall x y : R[*]. x < y => 
              (Pi (y - x)) -> 
              Lens (Pi y) (Pi x) (Pi (y - x))
projectLens = \ c.
    (#'missing :=  c, 
     #'putr := \ p. pair (prj (fst p)) (snd p) ,
     #'putl := \ p. pair (fst p ++ snd p) (snd p) )      

lens : forall l : L , t : *, c z : R[*]. {l := t} + c ~ z => 
              #l ->
              Pi c ->
              Lens (Pi z) t (Pi c)
lens = \ l c.
    (#'missing :=  c, 
     #'putr := \ p. pair (sel l (fst p)) (snd p) ,
     #'putl := \ p. pair ((l := (fst p)) ++ snd p) (snd p))        


dual : forall x y c. Lens x y c -> Lens y x c 
dual = \ l. 
    (#'missing :=  missing l , 
     #'putr :=  \ p. putl l p ,
     #'putl := \ p. putr l p)        

comp : forall x y z c1 c2. Lens x y c1 -> Lens y z c2 -> Lens x z (Pair c1 c2)
comp = \ k l. 
    (#'missing :=  pair (sel #'missing k) (sel #'missing l) , 
     #'putr :=  sorry ,
     #'putl := sorry)    




