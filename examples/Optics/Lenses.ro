import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List
{- 
-- reading list & notes:

  # Bidirectional transformations
    - Introduction to BX
      - https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/ssbx-intro.pdf
    - Combinators for Bidirectional Tree Transformations: A Linguistic Approach to the View-Update Problem
      - https://dl.acm.org/doi/pdf/10.1145/1232420.1232424

  # Symmetric lenses & complements
    - Symmetric Lenses
      - https://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf 
    - Complements Witness Consistency
      - https://groups.inf.ed.ac.uk/bx/2016-Bx-CWC.pdf
  
  # Lenses *without* combinators
    - HOBiT: Programming Lenses Without Lens Combinators.
      This may be a promising avenue of Rosi if we can realize BX sans combinators
      - https://mengwangoxf.github.io/Papers/ESOP18.pdf

  # Profunctor optics & prisms
    - What you need to know about Yoneda:
      - https://www.cs.ox.ac.uk/jeremy.gibbons/publications/proyo.pdf
    - Profunctor Optics: Modular Data Accessors
      (fairly accessible and implementation oriented)
      - https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf

  # Dependent lenses
    - Secondary reading that may be relevant to dependent rows
      - https://www.cse.chalmers.se/~nad/publications/danielsson-dependent-lenses.pdf
      - https://www.cse.chalmers.se/~nad/publications/capriotti-danielsson-vezzosi-higher-lenses.pdf

  # Open problems in BX
    - Towards a Repository of Bx Examples
      - https://www.cs.ox.ac.uk/jeremy.gibbons/publications/repo.pdf
        http://bx-community.wikidot.com/examples:home
    - Benchmarx:
      - https://ris.utwente.nl/ws/portalfiles/portal/5301511/bx2014.pdf
    - Benchmarx Reloaded (2017): 
      - https://ceur-ws.org/Vol-1827/paper6.pdf
    - Benchmarx 2.0 (for concurrent model synchronization), 2024: 
      - https://dl.acm.org/doi/pdf/10.1145/3652620.3688217
    - Provenance meets Bidirectional Transformations: 
      - https://www.usenix.org/system/files/tapp2019-paper-anjorin.pdf

  # The Van Laarhoven Representation
    The Data.Lens package represents a lens as:
      type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
    Some reading:
    - Functor is to Lens as Applicative is to Biplate:
      - https://arxiv.org/pdf/1103.2841
    - CPS based functional references:
      - https://www.twanvl.nl/blog/haskell/cps-functional-references

  # Research questions
    - What happens to a lens when its source type is extended or changed?
      I cannot find much in the literature about changes to *schema* of models.
      Consider the prototypical Benchmarx example:
        - FamilyToPersons http://bx-community.wikidot.com/examples:familytopersons
      The challenge is to convert instances of one model to the other---
      but what if the schema of a model is changed? E.g., the "name" field
      is renamed? Or a field is added or removed.
      Another example would be database migrations: how do we propagate
      changes to a table's schema to changes to that table's linked views?
      In essence I am trying to extract the expression problem in BX.
    - Composability of generalized, heterogeneous lenses:
        type Lens s t a b = { 'get := s -> a , 'put := s -> b -> t }
      This definition transforms the source type from s to t
      and the view type from a to b.
      The challenge here (I assume) is that it's not straightforward
      to compose two arbitrary lenses, hence nice composition is lost.
    - Composability of *optics* (how do I compose a lens with a prism?)
    - This section from Pickering et al strikes me:
      - "Prisms are an implementation of first-class patterns, unlike other proposals; for example, Tullsen
        [37] recognised the close connection between data constructors and pattern matching.
        Pattern matching is the method which is used to deconstruct values constructed by
        data constructors; first-class patterns should also be able to re-build the values that
        they match."
    - Another approach to BX is to write *one* function that runs in both directions.
      Can I extract `put` from an implementation of `get`?


-}
--------------------------------------------------------------------------------
-- to run (from home dir):
--   - cabal run Rosi -- -i rolib -i examples Optics.Lenses
-- to evaluate terms, e.g., showBob:
--   - cabal run Rosi -- -i rolib -i examples Optics.Lenses -e showBob

--------------------------------------------------------------------------------
-- The interface for lenses 
--
-- N.b. there are handful of equivalent representations one could use.
-- I follow the simplest and original, as proposed by Foster et al (2007).

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

type Lens : * -> * -> *
type Lens =  \ s t. Pi { 'get := s -> t , 'put := s -> t -> s }

get : forall s t : *. Lens s t -> s -> t 
get = sel #'get 

put : forall s t : *. Lens s t -> s -> t -> s 
put = sel #'put

-- Each label forms a lens 
lens : forall l : L , t : * , z : R[*]. {l := t} < z => #l -> Lens (Pi z) t
lens = \ l. (#'get := sel l , #'put := \ s t. (l := t) ++ prj s)

-- lenses may be composed
comp : forall a b c : *. Lens a b -> Lens b c -> Lens a c 
comp = \ x y. (#'get :=  o (get y) (get x) , #'put := \ a c. put x a (put y (get x a) c) )

--------------------------------------------------------------------------------
-- Asymmetric lenses (with complements)
-- TODO
-- AH> What do these really give?

{- -----------------------------------------------------------------------------
# A bit on lens laws
--------------------

Lenses are a solution to the classic database "view update" problem,
in which one asks what changes may be made to a "view" that can be reflected back
to a source. This question has inspired the vast field of Bidirectional Programming today,
of which lenses, prisms, and optics are a leading, language-theoretic solution.
Ensuring that changes to a view accurately reflect back to the source amounts
to the following laws.

Defn. A *well-behaved* lens (l : Lens S T) observes the following two laws:
- (GetPut): A round-trip from source back to source incurs no changes:
            put l s (get l s) = s    for all s : S
- (PutGet): The put function captures all of the information in the abstract view:
            get l (put l s t) = t    for all s : S , t : T

Defn. A lens (l : Lens S T) is called *very well-behaved* if in addition it observes:
- (PutPut): performing two puts ignores the first put.
            put l (put l s t) t' = put s t'   for all s : S and t, t' : T

There are a number of other laws and variants of these laws depending on which
particular type of lens you are working with. Because Rosi is not dependently typed,
we cannot prove any law directly in the theory of Rosi. Just as with e.g. functor
laws in Haskell, these must be verified by hand.

----------------------------------------------------------------------------- -} 

--------------------------------------------------------------------------------
-- An example nested record type

type Address : R[ * ]
type Address = { 'street := String , 'zip := Nat }

type Place : R[ * ]
type Place = { 'address := Pi Address , 'isApartment := Bool  }

type Person : R[ * ]
type Person = { 'age := Nat , 'place := Pi Place }

--------------------------------------------------------------------------------
-- Bob, an example Person

Bob : Pi Person
Bob = (#'age := 2 , 
       #'place := 
         (#'address     := (#'street := "Abbey Road" , #'zip := 1) ,
          #'isApartment := True))

--------------------------------------------------------------------------------
-- Pretty printing Bob

showAddress : ShowR Address
showAddress = (#'names := (#'street := "street" , #'zip := "zip") , #'shows := (#'street := id , #'zip := showNat))

showPlace : ShowR Place
showPlace = (#'names := (#'address := "address" , #'isApartment := "isApartment") , 
             #'shows := (#'address := showP showAddress , #'isApartment := showBool))

showPerson : ShowR Person
showPerson = (#'names := (#'age := "age" , #'place := "place") , #'shows := (#'age := showNat , #'place := showP showPlace))

showBob : String
showBob = showP showPerson Bob

--------------------------------------------------------------------------------
-- Getting and updating Bob with lenses

streetLens : Lens (Pi Person) String 
streetLens = comp (comp (lens #'place) (lens #'address)) (lens #'street)

-- Getting is straightforward
BobStreet : String
BobStreet = get streetLens Bob 

-- Updating is straightforward
movedBob : Pi Person 
movedBob = put streetLens Bob "1818 Pleasant St."

-- N.b., evaluating `put` terms causes my compiler to loop.
-- To reproduce, run:
--   cabal run Rosi -- -i rolib -i examples Optics.Lenses -e bug
bug : Pi Person 
bug = put (lens #'age) Bob 2

--------------------------------------------------------------------------------
-- Projection is a lens
-- ... and can be thought of as a solution to the classical view-update problem.
-- As an example,  consider the SQL query:
--   SELECT id , name from Users where id = 1
-- yielding the record ('id := 1 , 'name := Bob)
-- Invoking a put permits us to change the view and propagate that save back to the table.
-- Let xs be the full row for Bob in the `Users` table. Then
--      put xs ('id := 1 , 'name := Shirly)
--    = ('id := 1 , 'name := Shirly) ++ prj xs
-- where prj xs has all the fields of `Users` minus id and name.

-- We verify this lens is well-behaved:
--   - (GetPut). Let x + y ~ z and let zs : Pi z.
--        put projectLens zs (get projectLens zs)
--      = put projectLens zs ++ prj [x] [z] zs
--      = prj [x] [z] zs ++ prj [y] [z] zs
--      = zs
--   And
--   - (PutGet). Let x + y ~ z, xs : Pi x and zs : Pi z.
--        get projectLens (put projectLens zs xs)
--      = prj [x] [z] (put projectLens zs xs)
--      = prj [x] [z] (xs ++ prj [y] [z] zs)
--      = xs 
--   as desired.
projectLens : forall x y z : R[*]. x + y ~ z => 
              Lens (Pi z) (Pi x)
projectLens = /\ x y z. (#'get := prj [x] [z] , #'put := \ zs xs. xs ++ prj [y] [z] zs)              


--------------------------------------------------------------------------------
-- Concatenation is a lens
-- N.b. This would be a good candidate for asymmetric lenses w/ complements.
-- ((Pi y) is the complement.)
--
-- We verify this lens is well-behaved:
--   - (GetPut). Let p : Pair (Pi x) (Pi y)
--        put concatLens p (get concatLens p)
--      = put concatLens p (fst p ++ snd p)
--      = pair (prj [x] [z] (fst p ++ snd p)) (prj [y] [z] (fst p ++ snd p))
--      = pair (fst p) (snd p)
--      = p
--   And
--   - (PutGet). Let p : Pair (Pi x) (Pi y) and xs : Pi x
--        get concatLens (put concatLens xs p)
--      = get concatLens (pair (prj [x] [z] zs) (prj [y] [z] zs))
--      = fst (pair (prj [x] [z] zs) (prj [y] [z] zs)) ++ snd (pair (prj [x] [z] zs) (prj [y] [z] zs))
--      = (prj [x] [z] zs) ++ (prj [y] [z] zs)
--      = zs
concatLens : forall x y z : R[ * ]. x + y ~ z => 
             Lens (Pair (Pi x) (Pi y)) (Pi z)
concatLens = /\ x y z. (#'get := \ p.  fst p ++ snd p , #'put := \ p zs. pair (prj [x] [z] zs) (prj [y] [z] zs))

-- example
moreAboutBob = 
  showP (showRCat showPerson (#'names := (#'height := "height") , #'shows := (#'height := showNat)))
  (get concatLens (pair Bob (#'height := 2)))

--------------------------------------------------------------------------------
-- Joining is a lens

innerJoin : forall l : L , t : * , a b c d : R[*]. 
       {l := t} < a , {l := t} < b , 
        (a - {l := t}) + (b - {l := t}) ~ c , {l := t} + c ~ d => 
       #l -> (t -> t -> Bool) -> 
       List (Pi a) -> List (Pi b) -> List (Pi d)
innerJoin = \ l eq xs ys. sorry