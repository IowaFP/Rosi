import Data.Functor, Control.Applicative

type Traversable : (* -> *) -> *
type Traversable = \t. Pi { 'Functor := Functor t,
                            'sequence := forall f a. Applicative f -> t (f a) -> f (t a) }

traversableFunctor : forall z : R[* -> *]. Pi (Traversable z) -> Pi (Functor z)
traversableFunctor = mapP #Traversable #Functor (\l d. sel d #'Functor)

sequenceS : forall z : R[* -> *]. Pi (Traversable z) -> (forall f a. Applicative f -> Sigma z (f a) -> f (Sigma z a))
sequenceS  = \d. /\ f a. \applf v. ana #(\g. g (f a)) (\l x. sel applf #'Functor (con l) (sel (sel d l) #'sequence applf x)) v

traversableS : forall z : R[* -> *]. Pi (Traversable z) -> Traversable (Sigma z)
traversableS = \d. (#'Functor := fmapS (traversableFunctor d),
                    #'sequence := sequenceS d)

-- Doing this for Pi requires (at least) some kind of fold, so passing for now...

sequenceMaybe : forall f a. Applicative f -> Maybe (f a) -> f (Maybe a)
sequenceMaybe = \a.
    case #'Nothing (\u. sel a #'pure Nothing)
  | case #'Just (\x. sel a #'Functor Just x)

traversableMaybe : Traversable Maybe
traversableMaybe = ( #'Functor := functorMaybe
                   , #'sequence := sequenceMaybe )