import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Data.Functor , Control.Monad , Control.Monad.List

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

--------------------------------------------------------------------------------
-- Polymorphic adapters


--------------------------------------------------------------------------------
-- Polymorphic lenses

type Lens : * -> * -> * -> * -> *
type Lens =  \ a b s t. Pi { 'get := s -> a , 'put := s -> b -> t }

get = sel #'get 
put = sel #'put

modify : forall a b s t. Lens a b s t -> (a -> b) -> s -> t
modify = \ l f s. put l s (f (get l s))

-- -- Each label forms a lens 
lens : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
       #l -> Lens a b (Pi x) (Pi y)
lens = \ l. (#'get := sel l , #'put := \ s b. (l := b) ++ prj s)

-- Bijective lenses are lenses that ignore the source during a putback
-- (Bijective lenses are equivalent to adapters.)
bijective : forall a b s t : *. (s -> a) -> (b -> t) -> Lens a b s t 
bijective = \ get put. (#'get := get , #'put := \ s. put)

-- -- lenses may be composed
comp : forall a a' b b' s t : *. Lens a b s t -> Lens a' b'  a b -> Lens a' b' s t
comp = \ x y. (#'get :=  o (get y) (get x) , #'put := \ s b'. put x s (put y (get x s) b'))

--------------------------------------------------------------------------------
-- Prisms

type Prism : * -> * -> * -> * -> * 
type Prism = \ a b s t. Pi { 'get := s -> Either a t , 'put := b -> t }

-- each label creates a prism
prism : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
        #l -> Prism a b (Sigma x) (Sigma y)
prism = \ l. (#'get := case l Left | (o Right inj) , #'put := con l)

-- Prisms may be composed
compPrism : forall a a' b b' s t : *. Prism a b s t -> Prism a' b'  a b -> Prism a' b' s t
compPrism = \ x y. 
  (#'get := \ s. match (get x s) 
       (either (\ a. match (get y a) (either Left (o Right (put x)))) Right) , 
   #'put := o (put x) (put y))

--------------------------------------------------------------------------------
-- Adapters

type Adapter : * -> * -> * -> * -> * 
type Adapter = \ a b s t. Pi { 'from := s -> a , 'to := b -> t}

from = sel #'from 
to   = sel #'to

adapterLens : forall a b s t. Adapter a b s t -> Lens a b s t 
adapterLens = \ a. (#'get := from a , #'put := \ s t. to a t)

adapterPrism : forall a b s t. Adapter a b s t -> Prism a b s t 
adapterPrism = \ a. (#'get := o Left (from a) , #'put := to a)

--------------------------------------------------------------------------------
-- Traversals

-- Want to express:
--   data FunList a b t = Done t | More a (FunList a b (b -> t))
-- which is a nested datatype. Need higher-order Mu...
-- Maybe relevant reading:
--   - Nested Datatypes, Richard Bird:
--     https://www.cs.ox.ac.uk/richard.bird/online/BirdMeertens98Nested.pdf
--   - Patricia Johann, initial algebra semantics is enough!
--     https://libres.uncg.edu/ir/asu/f/Johann_Patricia_2007_Intitial%20Algebra%20Semantics%20Is%20Enough.pdf
-- Alternatively, can use a different representation of traversals.

-- type FunListF  : * -> * -> * -> (* -> * -> * -> *) -> * 
-- type FunListF = \ a b t X. Sigma {'Done := t , 'More := Pair a (X a b (b -> t)) }

-- type FunList  : * -> * -> * -> * 
-- type FunList = \ a b t. Mu (FunListF a b t)

-- type Traversal : * -> * -> * -> * 
-- type Traversal = \ a b s t. Pi {'over := (a -> b) -> s -> t , 'toListOf := s -> List a }
