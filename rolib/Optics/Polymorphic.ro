import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Data.Functor , Control.Monad , Control.Monad.List

--------------------------------------------------------------------------------
-- The interface for lenses 
--
-- N.b. there are handful of equivalent representations one could use.
-- I follow the simplest and original, as proposed by Foster et al (2007).

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

type Lens : * -> * -> * -> * -> *
type Lens =  \ a b s t. Pi { 'get := s -> a , 'put := s -> b -> t }

get = sel #'get 
put = sel #'put

modify : forall a b s t. Lens a b s t -> (a -> b) -> s -> t
modify = \ l f s. put l s (f (get l s))

-- -- Each label forms a lens 
lens : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
       #l -> Lens a b (Pi x) (Pi y)
lens = \ l. (#'get := sel l , #'put := \ s b. (l := b) ++ prj s)

-- -- lenses may be composed
-- comp : forall a b c : *. Lens a b -> Lens b c -> Lens a c 
-- comp = \ x y. (#'get :=  o (get y) (get x) , #'put := \ a c. put x a (put y (get x a) c) )

-- -- Bijective lenses are lenses that ignore the source during a putback
-- bijective : forall s t : *. (s -> t) -> (t -> s) -> Lens s t 
-- bijective = \ get put. (#'get := get , #'put := \ s. put)
