import Ro.Base , Ro.Show , Data.Nat , Data.Tuple , Data.Functor

--------------------------------------------------------------------------------
-- Simulating objects with recursive records
-- using a standard encoding from Wand:
--   - Type inference for record concatenation and multiple inheritance
--     - https://www.cs.tufts.edu/~nr/cs257/archive/mitch-wand/types-simple-objects.pdf
-- and Cook et al:
--   - Inheritance is not Subtyping
--     - https://www.cs.utexas.edu/~wcook/papers/InheritanceSubtyping90/CookPOPL90.pdf

--------------------------------------------------------------------------------
-- An example from Cook et al with class methods, mixed-variant recursive records,
-- and inheritance.

-- Record types serve as interfaces. An object permits references to "this"
-- (or "self"), which can be viewed as a recursive placeholder. Hence
-- we declare the type of a Point as a functor.
type PointF : R[* -> *]
type PointF = {
    'x     := Const Nat , 
    'y     := Const Nat , 
    'move  :=  \ Point. Pair Nat Nat -> Point , 
    'equal :=  \ Point. Point -> Bool ,
    'get   := Const (Pair Nat Nat) }

-- (For the categorically minded: yes, it is not really a *functor*, as it is mixed-variant.)
fmapPointF : Pi (Functor PointF)
fmapPointF = 
    (#'x := /\ a b. \ f x. x , 
     #'y := /\ a b. \ f y. y , 
     #'move := /\ a b. \ f move p. f (move p)  , 
     #'equal := /\ a b. \ f equal. sorry , -- <-- Negative occurrence in #'equal
     #'get := /\ a b. \ f p. p
     )

type Point : *
type Point = Mu (Pi PointF)

printPoint : forall z : R[*]. {'get := Pair Nat Nat } < z => Pi z -> String
printPoint = \ p. showPair showNat showNat (sel p #'get)

-- A class can be seen as an implementation of the interface with:
--  - A class method initializing the object (and possibly more class methods)
--  - A set of initial values
CartPoint : (Pair Nat Nat -> Point -> Point) -> 
            Pair Nat Nat -> Point -> Point
CartPoint = \ init p self. in
    (#'x := fst p , 
     #'y := snd p ,
     #'move := \ q. 
        fix (init (pair 
            (add (sel (out self) #'x) (fst q))
            (add (sel (out self) #'y) (snd q)))) ,
     #'equal := \ q.
        and (equal (sel (out self) #'x) (sel (out q) #'x))
            (equal (sel (out self) #'y) (sel (out q) #'y)) ,
     #'get := pair (sel (out self) #'x) (sel (out self) #'y))

-- We tie the knot to get the object initializer
newCartPoint : Pair Nat Nat -> Point
newCartPoint = \ p. fix (fix CartPoint p)

-- some examples
p1 : Point
p1 = newCartPoint (pair 0 0)

p2 : Point 
p2 = newCartPoint (pair 1 1)

p3 : Point 
p3 = sel (out p1) #'move (pair 3 4)

p3str : String 
p3str = printPoint (out p3)

p1eqp2 : String
p1eqp2 = showBool (sel (out p2) #'equal (sel (out p1) #'move (pair 2 2)))

-- testing that self links correctly.
p4 : Point 
p4 = in (prj (out p1) ++ (#'x := 1 , #'y := 1))

test0 : String 
test0 = printPoint (out p4)

test1 : String 
test1 = showPair showNat showNat (pair (sel (out p4) #'x) (sel (out p4) #'y))

-- --------------------------------------------------------------------------------
{- The definition of CartPoint above has tied the recursive knot too soon. 
    To illustrate, let 
     type Color = Pi {'r := Byte , 'g := Byte , 'b := Byte}
     type ColorPointF = PointF + {'color := Const Color}
     type ColorPointI = Mu (Pi ColorPointF)
   and consider this definition of a color point class, which extends CartPoint:
     class ColorPoint (x : Nat, y : Nat, c : Color) 
       extends CartPoint
       implements ColorPointF:
         method color : Color
           return c 
         method equal (p : ColorPoint) : Bool 
           return super.equal(p) and 
             (self.color = p.color)
  We have two issues:
    - The extension of CartPoint implies we will use the parent method CartPoint
      to initialize the ColorPoint. Something like:
        ColorPoint : (x : Nat, y : Nat, c : Color) -> ColorPoint
        ColorPoint = \ p. in (out (newCartPoint (prj p)) ++ (#'color := p.c))
      However, (out (newCartPoint p)) has subdata at type Mu (Pi PointF), and *not*
      at type Mu (Pi ColorPointF). This suggests we would need to map over 
      (out (newCartPoint p)) : (Pi PointF) (Mu (Pi PointF)). But we cannot!
        1. PointF is mixed-variant and hence *not* functorial
        2. We have no Mu (Pi PointF) -> Mu (Pi ColorPointF) function.

  The encoding in Cook et al types because they rely on "F bounded polymorphism",
  a form of polymorphism that identifies records structurally equivalent to one another
  but not necessarily in a subtyping relationship, for in-time coercions. 
  The annotation t < f t in the type:
    C : forall t. t < f t.
        ((Nat, Nat) -> t -> t) ->
        (Nat, Nat) -> t -> f t 
  where t < f t implies that t and f t are convertible modulo projection, 
  permits one to take the fixed-point of C. 
-}


-- Broken. One thought is to take in the complement:
--   Pi (z - PointF) (Mu (Pi z))
-- so that we may change the input/return type to Mu (Pi z).
-- Alternatively...
CartPoint' : forall z : R [ * -> * ]. PointF < z => 
            (Pair Nat Nat -> (Mu (Pi z)) -> (Mu (Pi z))) -> 
             Pair Nat Nat -> (Mu (Pi z)) -> (Pi PointF) (Mu (Pi z))
CartPoint' = \ init p self. 
    (#'x := fst p , 
     #'y := snd p ,
     #'move := \ q.
        fix (init (pair 
            (add (sel (out self) #'x) (fst q))
            (add (sel (out self) #'y) (snd q)))) ,
     #'equal := \ q. 
        and (equal (sel (out self) #'x) (sel (out q) #'x))
            (equal (sel (out self) #'y) (sel (out q) #'y)) ,
     #'get := pair (sel (out self) #'x) (sel (out self) #'y))

theProblem : forall x y : R[* -> *], a : *. x < y => 
        ((a -> Mu (Pi y) -> Mu (Pi y)) -> (a -> Mu (Pi y) -> Pi x (Mu (Pi y)))) -> 
        Pair (a -> Mu (Pi y) -> Mu (Pi y)) (Mu (Pi y))
theProblem = sorry     

-- newPoint : Pair Nat Nat -> Point 
-- newPoint = \ p. fix (fix CartPoint' p) 

-- tieKnot : forall z : R [ * -> * ]. PointF < z => Pair Nat Nat -> Mu (Pi z)
-- tieKnot = sorry


-- --------------------------------------------------------------------------------
-- -- With CartPoint made suitably generic, we can define a ColorPoint that inherits
-- -- from CartPoint.

-- type Byte : *
-- type Byte = Nat

-- type Color : *
-- type Color = Pi {'r := Byte , 'g := Byte , 'b := Byte}

-- type ColorPointF : R[* -> *]
-- type ColorPointF = forall z : R[* -> *]. PointF + {'color := Const Color} ~ z => z

-- type ColorPoint : *
-- type ColorPoint = Mu (Pi ColorPointF)

-- -- colorPoint : (Triple Nat Nat Color -> ColorPoint -> ColorPoint) -> 
-- --              Triple Nat Nat Color -> ColorPoint -> ColorPoint
-- -- colorPoint = \ init p self. 
-- --     (CartPoint ( \ q. rprj (fix (init (prj p ++ prj q)))) (prj p) self)
-- --     ++ (#'color := thd p)

-- --------------------------------------------------------------------------------
-- -- Mixin modules


