import Ro.Base , Ro.Show , Data.Nat , Data.Tuple , Data.Functor

--------------------------------------------------------------------------------
-- Simulating objects with recursive records
-- using a standard encoding from Wand:
--   - Type inference for record concatenation and multiple inheritance
--     - https://www.cs.tufts.edu/~nr/cs257/archive/mitch-wand/types-simple-objects.pdf
-- and Cook et al:
--   - Inheritance is not Subtyping
--     - https://www.cs.utexas.edu/~wcook/papers/InheritanceSubtyping90/CookPOPL90.pdf

--------------------------------------------------------------------------------
-- An example from Cook et al with class methods, mixed-variant recursive records,
-- and inheritance.

-- Record types serve as interfaces. An object permits references to "this"
-- (or "self"), which can be viewed as a recursive placeholder. Hence
-- we declare the type of a Point as a functor.
type PointF : R[* -> *]
type PointF = {
    'x     := Const Nat , 
    'y     := Const Nat , 
    'move  :=  \ Point. Pair Nat Nat -> Point , 
    'equal :=  \ Point. Point -> Bool ,
    'get   := Const (Pair Nat Nat) }

-- (For the categorically minded: yes, it is not really a *functor*, as it is mixed-variant.)
fmapPointF : Pi (Functor PointF)
fmapPointF = 
    (#'x := /\ a b. \ f x. x , 
     #'y := /\ a b. \ f y. y , 
     #'move := /\ a b. \ f move p. f (move p)  , 
     #'equal := /\ a b. \ f equal. sorry , -- <-- Negative occurrence in #'equal
     #'get := /\ a b. \ f p. p
     )

type Point : *
type Point = Mu (Pi PointF)

printPoint : forall z : R[*]. {'get := Pair Nat Nat } < z => Pi z -> String
printPoint = \ p. showPair showNat showNat (sel p #'get)

-- A class can be seen as an implementation of the interface with:
--  - A class method initializing the object (and possibly more class methods)
--  - A set of initial values
CartPoint : (Pair Nat Nat -> Point -> Point) -> 
            Pair Nat Nat -> Point -> Point
CartPoint = \ init p self. in
    (#'x := fst p , 
     #'y := snd p ,
     #'move := \ q. 
        fix (init (pair 
            (add (sel (out self) #'x) (fst q))
            (add (sel (out self) #'y) (snd q)))) ,
     #'equal := \ q.
        and (equal (sel (out self) #'x) (sel (out q) #'x))
            (equal (sel (out self) #'y) (sel (out q) #'y)) ,
     #'get := pair (sel (out self) #'x) (sel (out self) #'y))

-- We tie the knot to get the object initializer
newCartPoint : Pair Nat Nat -> Point
newCartPoint = \ p. fix (fix CartPoint p)

-- some examples
p1 : Point
p1 = newCartPoint (pair 0 0)

p2 : Point 
p2 = newCartPoint (pair 1 1)

p3 : Point 
p3 = sel (out p1) #'move (pair 3 4)

p3str : String 
p3str = printPoint (out p3)

p1eqp2 : String
p1eqp2 = showBool (sel (out p2) #'equal (sel (out p1) #'move (pair 2 2)))

-- testing that self links correctly.
p4 : Point 
p4 = in (prj (out p1) ++ (#'x := 1 , #'y := 1))

test0 : String 
test0 = printPoint (out p4)

test1 : String 
test1 = showPair showNat showNat (pair (sel (out p4) #'x) (sel (out p4) #'y))

-- --------------------------------------------------------------------------------
{- The definition of CartPoint above has tied the recursive knot too soon. 
    To illustrate, let 
     type Color = Pi {'r := Byte , 'g := Byte , 'b := Byte}
     type ColorPointF = PointF + {'color := Const Color}
     type ColorPointI = Mu (Pi ColorPointF)
   and consider this definition of a color point class, which extends CartPoint:
     class ColorPoint (x : Nat, y : Nat, c : Color) 
       extends CartPoint
       implements ColorPointF:
         method color : Color
           return c 
         method equal (p : ColorPoint) : Bool 
           return super.equal(p) and 
             (self.color = p.color)
  We have two issues:
    - The extension of CartPoint implies we will use the parent method CartPoint
      to initialize the ColorPoint. Something like:
        ColorPoint : (x : Nat, y : Nat, c : Color) -> ColorPoint
        ColorPoint = \ p. in (out (newCartPoint (prj p)) ++ (#'color := p.c))
      However, (out (newCartPoint p)) has subdata at type Mu (Pi PointF), and *not*
      at type Mu (Pi ColorPointF). This suggests we would need to map over 
      (out (newCartPoint p)) : (Pi PointF) (Mu (Pi PointF)). But we cannot!
        1. PointF is mixed-variant and hence *not* functorial
        2. We have no Mu (Pi PointF) -> Mu (Pi ColorPointF) function.

  The encoding in Cook et al types because they rely on "F bounded polymorphism",
  a form of polymorphism that identifies records structurally equivalent to one another
  but not necessarily in a subtyping relationship, for in-time coercions. 
  The annotation t < f t in the type:
    C : forall t. t < f t.
        ((Nat, Nat) -> t -> t) ->
        (Nat, Nat) -> t -> f t 
  where t < f t implies that t has a subset of the structure of f t. 
  When t = f t, we are permitted to take the fixed-point of C. Hence the crux
  of the problem is that Cook's system has equirecursive types whereas we
  have isorecursive types.
-}

CartPoint' : forall z : R [ * -> * ]. PointF < z => 
            (Pair Nat Nat -> (Mu (Pi z)) -> (Mu (Pi z))) -> 
             Pair Nat Nat -> (Mu (Pi z)) -> (Pi PointF) (Mu (Pi z))
CartPoint' = \ init p self. 
    (#'x := fst p , 
     #'y := snd p ,
     #'move := \ q.
        fix (init (pair 
            (add (sel (out self) #'x) (fst q))
            (add (sel (out self) #'y) (snd q)))) ,
     #'equal := \ q. 
        and (equal (sel (out self) #'x) (sel (out q) #'x))
            (equal (sel (out self) #'y) (sel (out q) #'y)) ,
     #'get := pair (sel (out self) #'x) (sel (out self) #'y))

-- A hack to permit fixed-points of heterogeneously-typed
-- functions is to compose the fixed-point with a conversion.
-- (This is quite ugly.)
fixC : forall a b : *. (b -> a) -> (a -> b) -> a
fixC = \ g f. fix (o g f)

-- We are only able to take the fixed-point when we instantiate
-- CartPoint' with PointF. 
newPoint : Pair Nat Nat -> Point 
newPoint = \ p. fix (fixC 
    [Pair Nat Nat -> (Mu (Pi PointF)) -> (Mu (Pi PointF))] 
    [Pair Nat Nat -> (Mu (Pi PointF)) -> (Pi PointF) (Mu (Pi PointF))] 
    (\ f p d. in (f p d)) (CartPoint' [PointF]) p) 

-- testing
p1' : Point
p1' = newPoint (pair 0 0)

p2' : Point 
p2' = newPoint (pair 1 1)

p3' : Point 
p3' = sel (out p1') #'move (pair 3 4)

p3Str : String 
p3Str = printPoint (out p3')

-- --------------------------------------------------------------------------------
-- -- With CartPoint made suitably generic, we can define a ColorPoint that inherits
-- -- from CartPoint.

-- type Byte : *
-- type Byte = Nat

-- type Color : *
-- type Color = Pi {'r := Byte , 'g := Byte , 'b := Byte}

-- type ColorPointF : R[* -> *]
-- type ColorPointF = forall z : R[* -> *]. PointF + {'color := Const Color} ~ z => z

-- type ColorPoint : *
-- type ColorPoint = Mu (Pi ColorPointF)

-- -- colorPoint : (Triple Nat Nat Color -> ColorPoint -> ColorPoint) -> 
-- --              Triple Nat Nat Color -> ColorPoint -> ColorPoint
-- -- colorPoint = \ init p self. 
-- --     (CartPoint ( \ q. rprj (fix (init (prj p ++ prj q)))) (prj p) self)
-- --     ++ (#'color := thd p)

-- --------------------------------------------------------------------------------
-- Generalization

type Class : R[* -> *] -> R[*] -> *
type Class = \ f args. forall z : R [ * -> * ]. f < z => 
            (Pi args -> (Mu (Pi z)) -> (Mu (Pi z))) -> 
             Pi args -> (Mu (Pi z)) -> (Pi f) (Mu (Pi z))

new : forall f : R[* -> *], args : R[*].  
      Class f args ->
      Pi args -> Mu (Pi f)
new = /\ f. \ class args. fix (fixC 
    (\ f p d. in (f p d)) (class [f]) args) 

extend : forall f g z : R[* -> *], fargs , gargs : R[*].
         f < g , z < g => 
         (Pi fargs -> Mu (Pi g) -> Mu (Pi g)) -> 
         (Pi gargs -> Pi fargs) ->
         Class f gargs -> 
         ((Pi f) (Mu (Pi g)) -> (Pi z) (Mu (Pi g))) ->
         Class g gargs 
extend = \ construct transformArgs super overrides init gargs self. 
  prj (super construct (transformArgs gargs) self) 
  ++ overrides (prj (super construct (transformArgs gargs) self))

          