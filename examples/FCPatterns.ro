import Ro.Base , Data.Nat , Optics.Monomorphic , Control.Monad
{- 
reading:

  # First class cases & patterns
  - First Class Patterns? Mark Tullsen 
    - Can't find pdf. https://link.springer.com/chapter/10.1007/3-540-46584-7_1
    - https://www.cambridge.org/core/services/aop-cambridge-core/content/view/968C982CA9B727A2C04D216EEF4E6CFC/S0956796808007144a.pdf/first-class-patterns.pdf
  - Views: a way for pattern matching to cohabit with data abstraction. Wadler, 1987
    - https://dl.acm.org/doi/10.1145/41625.41653
    - View patterns in Haskell:
      - https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/view_patterns.html
  - The view from the left. McBride and mcKinna, 2004
    - https://cs.ru.nl/~freek/courses/tt-2010/tvftl/conor-james-views.pdf    
  - Extensible Programming with First-Class Cases. Matthias Blume, Umut A. Acar, Wonseok Chae. 2006
    - https://www.brinckerhoff.org/clements/csc530-sp08/Readings/blume-2006.pdf    
  - Pattern Synonyms. Matthew Pickering, Gergo Erdi, Simon Peyton Jones, Richard Eisenberg. 2016
    - https://dl.acm.org/doi/pdf/10.1145/2976002.2976013    
  - First Class Patterns. Barry Jay, Delia Kesner, 2008
    - https://www.irif.fr/~kesner/papers/fcp.pdf    
  - Optimising First-Class Pattern Matching. Jeff Smits, Toine Hartman, Jesper Cockx, 2022
    - https://dl.acm.org/doi/pdf/10.1145/3567512.3567519

# On implementing pattern matching
  - Elaborating dependent (co)pattern matching: Nopattern left behind. Jesper Cockx and Andreas Abel, JFP 2020
    - https://www.cambridge.org/core/services/aop-cambridge-core/content/view/F13CECDAB2B6200135D45452CA44A8B3/S0956796819000182a.pdf/elaborating-dependent-copattern-matching-no-pattern-left-behind.pdf
  - How to compile pattern matching. Jules Jacobs
    - https://julesjacobs.com/notes/patternmatching/patternmatching.pdf
  - Eliminating dependent pattern matching. Healfdene Goguen, Conor McBride, James McKinna.
    - http://strictlypositive.org/goguen.pdf

Thoughts:    
  - A quote from Pickering et al (Profunctor Optics: Modular Data Accessors):
    - "Prisms are an implementation of first-class patterns, unlike other proposals; for example, Tullsen
    [37] recognised the close connection between data constructors and pattern matching.
    Pattern matching is the method which is used to deconstruct values constructed by
    data constructors; first-class patterns should also be able to re-build the values that
    they match."
-}

--------------------------------------------------------------------------------
-- Deep pattern matching in Rosi is necessarily nested

isEven : Nat -> Bool 
isEven = fix (\ isEven n. match (fmapNatF out (out n))
    ( case #'Zero (const True) 
    | case #'Succ (( case #'Succ isEven
                   | otherwise False))))

-- There is an interesting comparison to be made between prisms of type:
--   Pi { 'get := s -> Maybe t , 'put := t -> s }
-- and Wadler's *views*. We can view 'get as the LHS destructor and 'put
-- as the corresponding RHS constructor.

-- silly
caseOf : forall a b t : *. (a -> Maybe t) -> (t -> b) -> b -> a -> b
caseOf = \ get do b a. maybe b do  (get a)

-- Also silly, but illustrates how one might pattern match on accessors.
isEven' : Nat -> Bool 
isEven' = fix ( \ isEven' n.
  caseOf (is #'Zero) (const True) 
  (caseOf (composeMaybe (is #'Succ . out) (is #'Succ)) isEven' False (out n))
  (out n)) 

--------------------------------------------------------------------------------
-- A thought: bidirectional pattern synonyms in Rosi

pattern Just : forall a. a -> Sigma {'Just := a}
pattern Just a = (#'Just := a) 

-- its use on the rhs 
   foo  a = Just a 
-> foo = \ a. (#'Just := a)

-- its use on the LHS 
fromJust (Just a) = M 

-- elaborates to:
fromJust = (case #'Just (\ a. a)) 

-- Does it make more sense to specify both directions rather than try to synthesize?
pattern Just : forall a. a -> Sigma {'Just := a} 
Just =  \ a. (#'Just := a) <|> \ z. z\#'Just

pattern Nothing : Sigma {'Nothing := tt} | Sigma {'Nothing := tt}
pattern Nothing = (#'Nothing := tt) | (#'Nothing := tt)

-- Then 

maybe : Maybe a -> (a -> b) -> b -> Maybe b
maybe (Just a) f b = Just (f a)
maybe Nothing f b = b 

-- elaborates to...
-- (Not sure how to hack the unary constructor business)
maybe = \ j f b. match j 
  ((\ z. (\ a. Just (f a)) ((\ z. z\#'Just) z))
  | (\ z. b))

-- Unary constructors?
pattern True : Sigma ('True := tt) 
pattern True = (#'True := tt) + ()

-- Recursive types?


-- For records?
pattern Pair a b = pair a b | 

-- Nested patterns?
foo (Just (Just a)) = 
