-------------------------------------------------------------------------------
-- Functions

o : forall t u v. (u -> v) -> (t -> u) -> t -> v
o = \ f g x. f (g x)

type Id : * -> *
type Id = \x. x

id : forall t. t -> t
id = \x. x

type Const : * -> * -> *
type Const = \x y. x

const : forall t u. t -> u -> t
const = \ x y. x

-------------------------------------------------------------------------------
-- Unit type

type Unit : *
type Unit = Pi {}

tt : Unit
tt = prj (#'x := /\ a. \x. x)

-------------------------------------------------------------------------------
-- the any label

any : forall l : L. #l
any = /\ l. #l

-------------------------------------------------------------------------------
-- Convenience functions for records and variants

sel : forall l t z. {l := t} < z => Pi z -> #l -> t
sel = \ r l. prj r / l

con : forall l t z. {l := t} < z => #l -> t -> Sigma z
con = \l x. inj (l := x)

match : forall a b. a -> (a -> b) -> b
match = \x f. f x

case : forall l t u. #l -> (t -> u) -> Sigma { l := t } -> u
case = \ l f x. f (x / l)

otherwise : forall a b. a -> b -> a
otherwise = const

brnl : forall x z t. x < z => (Sigma x -> t) -> (Sigma z -> t) -> Sigma z -> t
brnl = \ f g. f | (o g (\x. inj x))

relabelS : forall l0 l1 t z y0 y1. {l0 := t} + z ~ y0, {l1 := t} + z ~ y1 =>
           #l0 -> #l1 -> Sigma y0 -> Sigma y1
relabelS = \ l0 l1. case l0 (con l1) | (\x. inj x)

relabelInj : forall y1 y0 l0 l1 t x z.
             {l0 := t} + x ~ y0, {l1 := t} + x ~ y1, y1 < z =>
             #l0 -> #l1 -> Sigma y0 -> Sigma z
relabelInj = /\y1. \l0 l1 x. inj (relabelS l0 l1 x : Sigma y1)

relabelP : forall l0 l1 t z y0 y1. {l0 := t} + z ~ y0, {l1 := t} + z ~ y1 =>
           #l0 -> #l1 -> Pi y0 -> Pi y1
relabelP = \ l0 l1 r. (l1 := sel r l0) ++ prj r

---

type Labels : R[*] -> R[*]
type Labels = \r. Const Unit r

upd : forall x' y z z'.
        y < z,
        x' + y ~ z',
        Labels (z - y) < Labels x' =>
        Pi x' -> Pi z -> Pi z'
upd = \r s. r ++ prj s

--------------------------------------------------------------------------------
-- The Bool type

type Bool : *
type Bool = Sigma { 'True := Unit, 'False := Unit }

True : Bool
True = con #'True tt

False : Bool
False = con #'False tt

ite : forall t : *. Bool -> t -> t -> t
ite = case #'True (\ u t1 t2. t1) 
    | case #'False (\ u t1 t2. t2)

not : Bool -> Bool
not = \ b. ite b False True 

and : Bool -> Bool -> Bool
and = \ b. ite b id (const False)

or : Bool -> Bool -> Bool
or = \ b. ite b (const True) id

--------------------------------------------------------------------------------
-- Bot elimination

impossible : forall a. Sigma {} -> a
impossible = fix (\x. x)

-------------------------------------------------------------------------------
-- Basic analysis / synthesis

reflect : forall z : R[*], t. Pi (z -> t) -> Sigma z -> t
reflect = \ d w. ana #(\X. X) (\ l u. sel d l u) w

reify : forall z t. (Sigma z -> t) -> Pi (z -> t)
reify = /\ z t. \f. syn #(\X. X -> t) (\l x. f (con l x))

every : forall a : *, z : R[*]. a -> Pi (Const a z)
every = /\a. \x. syn #(\X. a) (\l. x)

type Eq : * -> *
type Eq = \t. t -> t -> Bool

eqS : forall z : R[*]. Pi (Eq z) -> Eq (Sigma z)
eqS = \ d v. ana #(\X. X)
                 (\ l y. match v
                         ( case l (\x. sel d l x y)
                         | const False))

eqP : forall z: R[*]. Fold z => Pi (Eq z) -> Eq (Pi z)
eqP = \ d r. fold (\l x. sel d l (sel r l) x) and True

-------------------------------------------------------------------------------

eqUnit : Eq Unit
eqUnit = eqP tt

eqBool : Eq Bool
eqBool = eqS (every eqUnit)

-------------------------------------------------------------------------------

type Maybe : * -> *
type Maybe = \a. Sigma { 'Nothing := Unit, 'Just := a }

Just : forall a. a -> Maybe a
Just = \a. con #'Just a

Nothing : forall a. Maybe a
Nothing = con #'Nothing tt

maybe : forall a b. b -> (a -> b) -> Maybe a -> b
maybe = \z f.
        ( case #'Nothing (const z)
        | case #'Just f
        )

fromMaybe : forall a. a -> Maybe a -> a
fromMaybe = \z. maybe z id

-------------------------------------------------------------------------------

sorry : forall a. a
sorry = fix (\x. x)
