import Data.Functor, Control.Applicative , Data.List

type Monad : (* -> *) -> *
type Monad = \t. Pi { 'Applicative := Applicative t,
                      'bind := forall a b. t a -> (a -> t b) -> t b }


composeKleisli : forall t : * -> *, a b c : *. 
                 Monad t -> 
                 (b -> t c) -> (a -> t b) -> (a -> t c)
composeKleisli = \ m f g a. sel m #'bind (g a) f

bindMaybe : forall a b. Maybe a -> (a -> Maybe b) -> Maybe b
bindMaybe =
    case #'Nothing (\u k. Nothing)
  | case #'Just (\x k. k x)

monadMaybe : Monad Maybe
monadMaybe = ( #'Applicative := applicativeMaybe
             , #'bind := bindMaybe )

-- broken
-- composeMaybe : forall a b c. (b -> Maybe c) -> (a -> Maybe b) -> a -> Maybe c
-- composeMaybe = composeKleisli monadMaybe             

-- also broken
-- composeMaybe : forall a b c. (b -> Maybe c) -> (a -> Maybe b) -> a -> Maybe c
-- composeMaybe = composeKleisli sorry       

-- 
-- fixed
-- composeMaybe : forall a b c. (b -> Maybe c) -> (a -> Maybe b) -> a -> Maybe c
-- composeMaybe = /\ a b c. composeKleisli [Maybe] [a] [b] [c] monadMaybe