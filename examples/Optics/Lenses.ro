import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Control.Monad
{- 
-- reading list & notes:

  # Bidirectional transformations
    - Introduction to BX
      - https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/ssbx-intro.pdf
    - Combinators for Bidirectional Tree Transformations: A Linguistic Approach to the View-Update Problem
      - https://dl.acm.org/doi/pdf/10.1145/1232420.1232424

  # Symmetric lenses & complements
    - Symmetric Lenses
      - https://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf 
    - Complements Witness Consistency
      - https://groups.inf.ed.ac.uk/bx/2016-Bx-CWC.pdf
  
  # Lenses *without* combinators
    - HOBiT: Programming Lenses Without Lens Combinators.
      This may be a promising avenue of Rosi if we can realize BX sans combinators
      - https://mengwangoxf.github.io/Papers/ESOP18.pdf

  # Profunctor optics
    - What you need to know about Yoneda:
      - https://www.cs.ox.ac.uk/jeremy.gibbons/publications/proyo.pdf
    - Profunctor Optics: Modular Data Accessors
      (fairly accessible and implementation oriented)
      - https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf
    - Bartosz Milewski on optics:
      - https://bartoszmilewski.com/2022/04/05/teaching-optics-through-conspiracy-theories/
    - Invariant functor optics (easier to digest profunctors):
      - https://dl.acm.org/doi/pdf/10.1145/3191697.3191718

  # Dependent lenses
    - Secondary reading that may be relevant to dependent rows
      - https://www.cse.chalmers.se/~nad/publications/danielsson-dependent-lenses.pdf
      - https://www.cse.chalmers.se/~nad/publications/capriotti-danielsson-vezzosi-higher-lenses.pdf

  # Open problems in BX
    - Towards a Repository of Bx Examples
      - https://www.cs.ox.ac.uk/jeremy.gibbons/publications/repo.pdf
        http://bx-community.wikidot.com/examples:home
    - Benchmarx:
      - https://ris.utwente.nl/ws/portalfiles/portal/5301511/bx2014.pdf
    - Benchmarx Reloaded (2017): 
      - https://ceur-ws.org/Vol-1827/paper6.pdf
    - Benchmarx 2.0 (for concurrent model synchronization), 2024: 
      - https://dl.acm.org/doi/pdf/10.1145/3652620.3688217
    - Provenance meets Bidirectional Transformations: 
      - https://www.usenix.org/system/files/tapp2019-paper-anjorin.pdf

  # The Van Laarhoven Representation
    The Data.Lens package represents a lens as:
      type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
    Some reading:
    - Functor is to Lens as Applicative is to Biplate:
      - https://arxiv.org/pdf/1103.2841
    - CPS based functional references:
      - https://www.twanvl.nl/blog/haskell/cps-functional-references

  # Research questions
    - What happens to a lens when its source type is extended or changed?
      I cannot find much in the literature about changes to *schema* of models.
      Consider the prototypical Benchmarx example:
        - FamilyToPersons http://bx-community.wikidot.com/examples:familytopersons
      The challenge is to convert instances of one model to the other---
      but what if the schema of a model is changed? E.g., the "name" field
      is renamed? Or a field is added or removed.
      Another example would be database migrations: how do we propagate
      changes to a table's schema to changes to that table's linked views?
      In essence I am trying to extract the expression problem in BX.
    - Composability of generalized, heterogeneous lenses:
        type Lens s t a b = { 'get := s -> a , 'put := s -> b -> t }
      This definition transforms the source type from s to t
      and the view type from a to b.
      The challenge here (I assume) is that it's not straightforward
      to compose two arbitrary lenses, hence nice composition is lost.
    - Composability of *optics* (how do I compose a lens with a prism?)
    - This section from Pickering et al strikes me:
      - "Prisms are an implementation of first-class patterns, unlike other proposals; for example, Tullsen
        [37] recognised the close connection between data constructors and pattern matching.
        Pattern matching is the method which is used to deconstruct values constructed by
        data constructors; first-class patterns should also be able to re-build the values that
        they match."
    - Another approach to BX is to write *one* function that runs in both directions.
      Can I extract `put` from an implementation of `get`?

  # Todo
  - asymmetric lenses w/ complements
  - symmetric lenses
  - Polymorphic lenses
  - Profunctor optics
  - Prisms

-}
--------------------------------------------------------------------------------
-- to run (from home dir):
--   - cabal run Rosi -- -i rolib -i examples Optics.Lenses
-- to evaluate terms, e.g., showBob:
--   - cabal run Rosi -- -i rolib -i examples Optics.Lenses -e showBob

--------------------------------------------------------------------------------
-- The interface for lenses 
--
-- N.b. there are handful of equivalent representations one could use.
-- I follow the simplest and original, as proposed by Foster et al (2007).

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

type Lens : * -> * -> *
type Lens =  \ s t. Pi { 'get := s -> t , 'put := s -> t -> s }

get = sel #'get 
put = sel #'put

-- Each label forms a lens 
lens : forall l : L , t : * , z : R[*]. {l := t} < z => #l -> Lens (Pi z) t
lens = \ l. (#'get := sel l , #'put := \ s t. (l := t) ++ prj s)

-- lenses may be composed
comp : forall a b c : *. Lens a b -> Lens b c -> Lens a c 
comp = \ x y. (#'get :=  o (get y) (get x) , #'put := \ a c. put x a (put y (get x a) c) )

-- Bijective lenses are lenses that ignore the source during a putback
bijective : forall s t : *. (s -> t) -> (t -> s) -> Lens s t 
bijective = \ get put. (#'get := get , #'put := \ s. put)

--------------------------------------------------------------------------------
-- Prisms

type Prism : * -> * -> * 
type Prism = \ s t. Pi { 'get := s -> Maybe t , 'put := t -> s }

-- each lens creates a prism
prism : forall l : L , t : * , z : R[*]. {l := t} < z => #l -> Prism (Sigma z) t
prism = \ l. (#'get := case l Just | otherwise Nothing , #'put := con l)

-- Prisms may be composed
compPrism : forall a b c : *. Prism a b -> Prism b c -> Prism a c 
compPrism = \ l u. (#'get := composeKleisli monadMaybe (get u) (get l) , #'put := o (put l) (put u) )

{- -----------------------------------------------------------------------------
# A bit on lens laws
--------------------

Lenses are a solution to the classic database "view update" problem,
in which one asks what changes may be made to a "view" that can be reflected back
to a source. This question has inspired the vast field of Bidirectional Programming today,
of which lenses, prisms, and optics are a leading, language-theoretic solution.
Ensuring that changes to a view accurately reflect back to the source amounts
to the following laws.

Defn. A *well-behaved* lens (l : Lens S T) observes the following two laws:
- (GetPut): A round-trip from source back to source incurs no changes:
            put l s (get l s) = s    for all s : S
- (PutGet): The put function captures all of the information in the abstract view:
            get l (put l s t) = t    for all s : S , t : T

Defn. A lens (l : Lens S T) is called *very well-behaved* if in addition it observes:
- (PutPut): performing two puts ignores the first put.
            put l (put l s t) t' = put s t'   for all s : S and t, t' : T

There are a number of other laws and variants of these laws depending on which
particular type of lens you are working with. Because Rosi is not dependently typed,
we cannot prove any law directly in the theory of Rosi. Just as with e.g. functor
laws in Haskell, these must be verified by hand.

----------------------------------------------------------------------------- -} 

--------------------------------------------------------------------------------
-- Projection is a lens

-- We verify this lens is well-behaved:
--   - (GetPut). Let x + y ~ z and let zs : Pi z.
--        put projectLens zs (get projectLens zs)
--      = put projectLens zs ++ prj [x] [z] zs
--      = prj [x] [z] zs ++ prj [y] [z] zs
--      = zs
--   And
--   - (PutGet). Let x + y ~ z, xs : Pi x and zs : Pi z.
--        get projectLens (put projectLens zs xs)
--      = prj [x] [z] (put projectLens zs xs)
--      = prj [x] [z] (xs ++ prj [y] [z] zs)
--      = xs 
--   as desired.
projectLens : forall x y : R[*]. x < y => 
              Lens (Pi y) (Pi x)
projectLens = /\ x y. (#'get := prj [x] [y] , #'put := \ zs xs. xs ++ prj [y - x] [y] zs)              

--------------------------------------------------------------------------------
-- Concatenation is a lens
-- N.b. This would be a good candidate for asymmetric lenses w/ complements.
-- ((Pi y) is the complement.)
--
-- We verify this lens is well-behaved:
--   - (GetPut). Let p : Pair (Pi x) (Pi y)
--        put concatLens p (get concatLens p)
--      = put concatLens p (fst p ++ snd p)
--      = pair (prj [x] [z] (fst p ++ snd p)) (prj [y] [z] (fst p ++ snd p))
--      = pair (fst p) (snd p)
--      = p
--   And
--   - (PutGet). Let p : Pair (Pi x) (Pi y) and xs : Pi x
--        get concatLens (put concatLens xs p)
--      = get concatLens (pair (prj [x] [z] zs) (prj [y] [z] zs))
--      = fst (pair (prj [x] [z] zs) (prj [y] [z] zs)) ++ snd (pair (prj [x] [z] zs) (prj [y] [z] zs))
--      = (prj [x] [z] zs) ++ (prj [y] [z] zs)
--      = zs
concatLens : forall x y z : R[ * ]. x + y ~ z => 
             Lens (Pair (Pi x) (Pi y)) (Pi z)
concatLens = /\ x y z. (#'get := \ p.  fst p ++ snd p , #'put := \ p zs. pair (prj [x] [z] zs) (prj [y] [z] zs))

--------------------------------------------------------------------------------
-- Injection is a prism

injectPrism : forall x y : R[*]. x < y => 
              Prism (Sigma y) (Sigma x)
injectPrism = (#'get := Just | otherwise Nothing , #'put := inj)

--------------------------------------------------------------------------------
-- Branching is a prism

branchPrism : forall x y z : R[*]. x + y ~ z => 
              Prism (Sigma z) (Either (Sigma x) (Sigma y))
branchPrism = (#'get := o Just Left | o Just Right , #'put := case #'Left inj | case #'Right inj)      

-- and a lens on eliminators
branchLens : forall x y z : R[*], t : *. x + y ~ z => 
              Lens (Pair (Sigma x -> t) (Sigma y -> t)) (Sigma z -> t)
branchLens = bijective (\ p. fst p | snd p) (\ t. pair (o t inj) (o t inj))

--------------------------------------------------------------------------------
-- Joining is a lens (TODO)
-- (Do I care?)

innerJoin : forall l : L , t : * , a b c d : R[*]. 
       {l := t} < a , {l := t} < b , 
        (a - {l := t}) + (b - {l := t}) ~ c , {l := t} + c ~ d => 
       #l -> (t -> t -> Bool) -> 
       List (Pi a) -> List (Pi b) -> List (Pi d)
innerJoin = \ l eq xs ys. sorry

--------------------------------------------------------------------------------
-- A Pi to Sigma lens

toS : forall l : L , t : *, r : R[*]. {l := t} < r => #l -> Pi r -> Sigma r 
toS = \ l d. inj (l := sel l d)

patch : forall r: R[*]. Pi r -> Sigma r -> Pi r
patch = \ d v. ana #(\X. X) (\ l u. prj d ++ (l := u)) v

RecToVarLens : forall l : L , t : *, r : R[*]. {l := t} < r => #l -> Lens (Pi r) (Sigma r)
RecToVarLens = \ l. (#'get := toS l , #'put := patch)

-- reify & reflect lenses;
-- tricky (if not impossible, for now) to verify the GetPut and PutGet laws.
rrLens : forall z : R[*], t : *. Lens (Pi (z -> t)) (Sigma z -> t)
rrLens = bijective reflect reify


--------------------------------------------------------------------------------
-- Asymmetric lenses with complements

--------------------------------------------------------------------------------
-- Symmetric lenses

--------------------------------------------------------------------------------
-- Prisms w/ complements

--------------------------------------------------------------------------------
-- polymorphic lenses & prisms

-- #############################################################################
-- Examples
-- #############################################################################

--------------------------------------------------------------------------------
-- An example from Pickering et al

type Number : * 
type Number = String

type ID : * 
type ID = String

type Name : *
type Name = String

type Contact : *
type Contact = Sigma {'Phone := Number , 'Skype := ID }

type Entry : * 
type Entry = Sigma {'Entry := Pair Name Contact }

type Book : * 
type Book = Tree Entry

-- Define a prism onto phone
-- phone : Prism Contact Number
-- phone = ?

-- Define a lens onto Contact
-- contact : Lens Entry Contact
-- contact = ?

-- Compose the two into a traversal (?)
-- contactPhone : Traversal Entry Number
-- contactPhone = ?

-- Combine with in-order traversal to access all phone numbers in a Book of contacts
-- bookPhones : Traversal Book Number
-- bookPhones = inOrderP . contact . phone



--------------------------------------------------------------------------------
-- An example nested record type

type Address : R[ * ]
type Address = { 'street := String , 'zip := Nat }

type Place : R[ * ]
type Place = { 'address := Pi Address , 'isApartment := Bool  }

type Person : R[ * ]
type Person = { 'age := Nat , 'place := Pi Place }

--------------------------------------------------------------------------------
-- Bob, an example Person

Bob : Pi Person
Bob = (#'age := 2 , 
       #'place := 
         (#'address     := (#'street := "Abbey Road" , #'zip := 1) ,
          #'isApartment := True))

--------------------------------------------------------------------------------
-- Pretty printing Bob

showAddress : ShowR Address
showAddress = (#'names := (#'street := "street" , #'zip := "zip") , #'shows := (#'street := id , #'zip := showNat))

showPlace : ShowR Place
showPlace = (#'names := (#'address := "address" , #'isApartment := "isApartment") , 
             #'shows := (#'address := showP showAddress , #'isApartment := showBool))

showPerson : ShowR Person
showPerson = (#'names := (#'age := "age" , #'place := "place") , #'shows := (#'age := showNat , #'place := showP showPlace))

showBob : String
showBob = showP showPerson Bob

--------------------------------------------------------------------------------
-- Getting and updating Bob with label lenses

streetLens : Lens (Pi Person) String 
streetLens = comp (comp (lens #'place) (lens #'address)) (lens #'street)

-- Getting is straightforward
BobStreet : String
BobStreet = get streetLens Bob 

-- Updating is straightforward
movedBob : Pi Person 
movedBob = put streetLens Bob "1818 Pleasant St."

-- N.b., evaluating `put` terms causes my compiler to loop.
-- To reproduce, run:
--   cabal run Rosi -- -i rolib -i examples Optics.Lenses -e bug
bug : Pi Person 
bug = put (lens #'age) Bob 2

-- Manipulating with other lenses
ageAndHeight : forall x : R[*]. 
               {'height := Nat} < x => 
               Pi Person -> Pi x -> Pi {'age := Nat , 'height := Nat}
ageAndHeight =  /\ x. \ p d. (get (comp concatLens projectLens) (pair p (prj [{'height := Nat}] [x] d)))

-- Challenge: make this extensible, e.g.,
--   {'height := Nat} < x => Pi Person -> Pi x -> ...
ageAndHeightPut : Pi Person -> Pi {'height := Nat} -> Pair (Pi Person) (Pi {'height := Nat})
ageAndHeightPut = \ p d. 
  put (comp concatLens projectLens) (pair p d) (#'age := 3 , #'height := 2)

newAgeBob : Pi Person
newAgeBob = put projectLens Bob (#'age := 3)

--------------------------------------------------------------------------------
-- An example from HoBiT
