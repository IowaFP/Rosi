import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List , Data.Tree , Data.Functor , 
       Control.Monad , Control.Applicative , Control.Monad.List

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

--------------------------------------------------------------------------------
-- Polymorphic lenses

type Lens : * -> * -> * -> * -> *
type Lens =  \ a b s t. Pi { 'get := s -> a , 'put := s -> b -> t }

get = sel #'get 
put = sel #'put

modify : forall a b s t. Lens a b s t -> (a -> b) -> s -> t
modify = \ l f s. put l s (f (get l s))

-- -- Each label forms a lens 
lens : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
       #l -> Lens a b (Pi x) (Pi y)
lens = \ l. (#'get := sel l , #'put := \ s b. (l := b) ++ prj s)

-- Bijective lenses are lenses that ignore the source during a putback
-- (Bijective lenses are equivalent to adapters.)
bijective : forall a b s t : *. (s -> a) -> (b -> t) -> Lens a b s t 
bijective = \ get put. (#'get := get , #'put := \ s. put)

-- lenses may be composed (n.b. this is (;), not \circ)
comp : forall a b s t c d : *. Lens c d s t -> Lens a b c d -> Lens a b s t
comp = \ x y. (#'get :=  (get y) . (get x) , #'put := \ s b'. put x s (put y (get x s) b'))

-- convert to the van Laarhoven representation
lensToVL : forall a b s t. Lens a b s t -> (forall f : * -> *. Functor f -> (a -> f b) -> s -> f t)
lensToVL = \ l fmap f s. fmap (put l s) (f (get l s))


--------------------------------------------------------------------------------
-- Polymorphic Prisms

type Prism : * -> * -> * -> * -> * 
type Prism = \ a b s t. Pi { 'get := s -> Either a t , 'put := b -> t }

-- each label creates a prism
prism : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
        #l -> Prism a b (Sigma x) (Sigma y)
prism = \ l. (#'get := case l Left | Right . inj , #'put := con l)

prism : forall l : L , a b : * , c x y : R[*]. {l := a} + c ~ x , {l := b} + c ~ y => 
        #l -> Prism a b (Sigma x) (Sigma y)

-- Prisms may be composed (n.b. this is (;), not \circ)
compPrism : forall a b c d s t : *. Prism c d s t -> Prism a b c d -> Prism a b s t
compPrism = \ x y. 
  (#'get := \ s. match (get x s) 
       (either (\ a. match (get y a) (either Left (Right . (put x)))) Right) , 
   #'put := (put x) . (put y))

--------------------------------------------------------------------------------
-- Polymorphic Adapters

type Adapter : * -> * -> * -> * -> * 
type Adapter = \ a b s t. Pi { 'from := s -> a , 'to := b -> t}

from = sel #'from 
to   = sel #'to

adapterLens : forall a b s t. Adapter a b s t -> Lens a b s t 
adapterLens = \ a. (#'get := from a , #'put := \ s t. to a t)

adapterPrism : forall a b s t. Adapter a b s t -> Prism a b s t 
adapterPrism = \ a. (#'get := Left . (from a) , #'put := to a)

-- symmetrize an adapter 
flip : forall a b s t. Adapter a b s t -> Adapter t s b a 
flip = \ adp. (#'from := sel #'to adp , #'to := sel #'from adp)

-- iso-recursive types adapter 
rec : forall f : * -> *. Adapter (f (Mu f)) (f (Mu f)) (Mu f) (Mu f)
rec = (#'from := out , #'to := in)

compAdapter : forall a b c d s t. Adapter c d s t -> Adapter a b c d -> Adapter a b s t
compAdapter = \ t u. (#'from :=  from u . from t , #'to := to t . to u)

--------------------------------------------------------------------------------
-- Traversals

-- Pickering et al describes the a traversal as
--   type Traversal = Traversal { extract :: s -> FunList a b t }
-- where 
--   type FunListF  : (* -> * -> * -> *) -> * -> * -> * -> * 
--   type FunListF = \ F a b t. Sigma {'Done := t , 'More := Pair a (F a b (b -> t)) }
--   type FunList  : * -> * -> * -> * 
--   type FunList = Mu FunListF
-- The type FunList a b t is isomorphic to a^n * (b^n -> t).
-- Unfortunately to construct/destruct such data we would need `in` and `out` at type:
--   in  : F (Mu FunListF) a b t -> Mu FunlistF a b t
--   out : Mu FunlistF a b t -> F (Mu FunListF) a b t
-- which we don't have. Instead, we will use the van Laarhoven encoding.

type Traversal : * -> * -> * -> * -> *
type Traversal = \ a b s t. forall f : * -> *. Applicative f -> (a -> f b) -> s -> f t

-- recovering the more concrete Traversal interface of Monomorphic lenses
over : forall a b s t. Traversal a b s t -> (a -> b) -> s -> t 
over = \ t. t [Id] applicativeId

listOf : forall a s. Traversal a a s s -> s -> List a
listOf = /\ a. \ t. t [Const (List a)] (applicativeConst monoidList) sing

-- every lens forms a traversal
lensTraversal : forall a b s t. Lens a b s t -> Traversal a b s t
lensTraversal = \ l ap. lensToVL l (sel #'Functor ap)

-- every prism forms a traversal 
prismTraversal : forall a b s t. Prism a b s t -> Traversal a b s t
prismTraversal = \ p ap g s. match (get p s)
  (case #'Left (\ a. sel #'Functor ap (put p) (g a)) | case #'Right (sel #'pure ap))

-- Traversals may be composed
compTraversal : forall a b c d s t : *. Traversal a b s t -> Traversal c d  a b -> Traversal c d s t
compTraversal = \ f g ap.  (f ap) . (g ap)

-- sequencing of a list
sequence : forall a, f : * -> *. Applicative f -> List (f a) -> f (List a)
sequence = \ ap. fix ( \sequence xs. match (out xs) 
  ( case #'Nil (const (sel #'pure ap nil))
  | case #'Cons (\ p. sel #'ap ap 
       (sel #'ap ap 
         (sel #'pure ap cons) (fst p)) 
       (sequence (snd p)))))

-- In order traversal of a list
inOrder : forall a b. Traversal a b (List a) (List b)
inOrder = \ ap f. sequence ap . map f
