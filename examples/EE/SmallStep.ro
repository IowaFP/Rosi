import Ro.Base, Ro.Xr, Data.Functor, Data.List, Data.Nat, Data.Tuple, EE.Types

-------------------------------------------------------------------------------
-- Substitution

type BindF : R[* -> *]
type BindF = { 'Var := Const Nat, 'Lam := Id }

substF : Xh BindF (\y. Nat -> Mu (Sigma y) -> Mu (Sigma y))
substF = \ exp rec i m.
  match exp
  ( case #'Var (\j. match (equal i j)
                    ( case #'True (const m)
                    | otherwise (con #'Var j)))
  | case #'Lam (\e. con #'Lam (rec e (succ i) m)))

extS : forall z : R[* -> *]. Pi (Functor z) -> Xh z (\y. Nat -> Mu (Sigma y) -> Mu (Sigma y))
extS = \d exp rec i m. inj (fmapS d (\x. rec x i m) exp)

subst : forall z. BindF < z =>
        Pi (Functor z) ->
        Mu (Sigma z) -> Nat -> Mu (Sigma z) -> Mu (Sigma z)
subst = \d. histo (substF | extS (prj d))

-------------------------------------------------------------------------------
-- Small-step evaluation

type Step : R[* -> *] -> *
type Step = \y : R[* -> *]. Pi (Functor y) -> Maybe (Mu (Sigma y))

stepA : Xh ArithF Step
stepA = \ exp rec d.
  match exp
  ( 'IConst: u -> Nothing
  | 'Plus: p ->
    match (fst p)
    ( 'IConst: i ->
      match (snd p)
      ( 'IConst: j -> Just ('IConst: (add i j))
      | otherwise ->
        match (rec (snd p) d)
        ( 'Just: sndd -> Just ('Plus: (pair ('IConst: i) sndd))
        | otherwise -> Nothing))
    | otherwise (
      match (rec (fst p) d)
      ( 'Just: fstt -> Just ('Plus: (pair fstt (snd p)))
      | otherwise ->
        match (rec (snd p) d)
        ( case #'Just (\sndd. Just (con #'Plus (pair (fst p) sndd)))
        | otherwise -> Nothing )))))

stepB : Xh BoolF Step
stepB = \ exp rec d.
  match exp
  ( case #'BConst (const Nothing)
  | case #'If (\ t.
    match (fst t)
    ( case #'BConst
      ( case #'True (const (Just (snd t)))
      | case #'False (const (Just (thd t))) )
    | otherwise
      ( match (rec (fst t) d)
        ( case #'Just (\fstt. Just (con #'If (triple fstt (snd t) (thd t))))
        | otherwise (
          match (rec (snd t) d)
          ( case #'Just (\sndd. Just (con #'If (triple (fst t) sndd (thd t))))
          | otherwise (
            match (rec (thd t) d)
            ( case #'Just (\thdd. Just (con #'If (triple (fst t) (snd t) thdd)))
            | otherwise Nothing )))))))))

stepF : Xh LamF Step
stepF = \ exp rec d.
  match exp
  ( case #'App (\ p.
    match (fst p)
    ( case #'Lam (\e. Just (subst d e 0 (snd p)))
    | otherwise (
      match (rec (fst p) d)
      ( case #'Just (\fstt. Just (con #'App (pair fstt (snd p))))
      | otherwise (
        match (rec (snd p) d)
        ( case #'Just (\sndd. Just (con #'App (pair (fst p) sndd)))
        | otherwise Nothing ))))))
  | otherwise Nothing )

step : Xh ABLF Step
step = stepA | stepB | stepF

-------------------------------------------------------------------------------

steps : forall z. (Mu (Sigma z) -> Maybe (Mu (Sigma z))) -> Mu (Sigma z) -> Mu (Sigma z)
steps = \step. fix (\steps z. match (step z) (case #'Nothing (const z) | case #'Just steps))

aexp : Mu (Sigma ABLF)
aexp = con #'Plus (pair (con #'Plus (pair (con #'IConst one) (con #'IConst one))) (con #'IConst one))

aexpS : String
aexpS = showExpr showABLF aexp

astep : Maybe (Mu (Sigma ABLF))
astep = histo step aexp functorABLF

asteps : Mu (Sigma ABLF)
asteps = steps (\x. histo step x functorABLF) aexp

astepsS : String
astepsS = showExpr showABLF asteps

exp : Mu (Sigma ABLF)
exp = con #'App (pair (con #'Lam (con #'Plus (pair (con #'Var zero) (con #'Var zero))))
                      (con #'IConst one))

expS : String
expS = showExpr showABLF exp

esteps : Mu (Sigma ABLF)
esteps = steps (\x. histo step x functorABLF) exp

estepsS : String
estepsS = showExpr showABLF esteps