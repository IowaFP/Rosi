import Ro.Base, Ro.Show , Ro.Xr, Data.Functor, Data.Nat, Data.Tuple

type ListF : * -> * -> *
type ListF = \a. Sigma { 'Nil := Const Unit, 'Cons := \l. Pair a l }

type List : * -> *
type List = \a. Mu (ListF a)

nil : forall a. List a
nil = rcon #'Nil tt

cons : forall a. a -> List a -> List a
cons = \hd tl. rcon #'Cons (pair hd tl)

sing : forall a. a -> List a 
sing = \ a. cons a nil

head : forall a. List a -> Maybe a
head = \l. match (out l)
           ( case #'Nil (const Nothing)
           | case #'Cons (o Just fst)
           )

tail : forall a. List a -> List a
tail = \l. match (out l)
           ( case #'Nil (const nil)
           | case #'Cons snd
           )

nth : forall a. List a -> Nat -> Maybe a
nth = fix (\f l n.
            match (out n)
            ( case #'Zero (const (head l))
            | case #'Succ (f (tail l))
            ))

map : forall a b. (a -> b) -> List a -> List b
map = fix (\ map f xs.
              match (out xs)
                ( case #'Nil (const nil)
                | case #'Cons (\ ys. cons (f (fst ys)) (map f (snd ys)))))

foldr : forall a b. (a -> b -> b) -> b -> List a -> b 
foldr = fix (\ foldr f b xs. match (out xs) 
          ((case #'Nil (const b))
        |  (case #'Cons (\ ys. f (fst ys) (foldr f b (snd ys)) ))))

append : forall a. List a -> List a -> List a 
append = \ xs ys. foldr cons ys xs

concat : forall a. List (List a) -> List a 
concat = foldr append nil

showList : forall a. Show a -> Show (List a)
showList = \ show. fix ( \ showList xs. match (out xs) 
    ( (case #'Nil (const "[]"))
    | (case #'Cons (\ p. show (fst p) ^ " :: " ^ showList (snd p)))))

listTest1 = nth (cons one (cons two (cons three nil))) two
listTest2 = nth (cons one (cons two nil)) two