import Ro.Base

type NatF : * -> *
type NatF = \n. Sigma { 'Zero := Unit, 'Succ := n}

type Nat : *
type Nat = Mu NatF

Zero : forall a. Unit -> Sigma { 'Zero := Unit, 'Succ := a }
Zero = \x. inj ((#'Zero := x) : Sigma { 'Zero := Unit })

Succ : forall a. a -> Sigma { 'Zero := Unit, 'Succ := a }
Succ = con #'Succ

z : NatF (NatF (NatF Unit))
z = Succ (Succ (Zero tt))

zero : Nat
zero = in (Zero tt : NatF (Mu NatF))

succ : Nat -> Nat
succ = \n. in (Succ n : NatF (Mu NatF))

one : Nat
one = succ zero

two : Nat
two = succ one

add : Nat -> Nat -> Nat
add = \m. fix (\add n. (case #'Zero (\u. m) | case #'Succ (\nn. succ (add nn))) (out n))

three : Nat
three = add one two

--------
-- Folds

type NatFAlg : * -> *
type NatFAlg = \a. NatF a -> a

{-

Let's imagine we understand categories:

    F (Mu F)  -- in --->  Mu F
       |                   |
       |                   |
    fmap (fold f)       fold f
       |                   |
       |                   |
       V                   V
      F a   --  f ---->    a

---

Suppose we have f : NatFAlg X -> X

  (fold f) (in (succ (in (succ (in (succ (in zero))))))
=
  f (fmap (fold f) (succ (in (succ (in (succ (in zero)))))
=
  f (succ ((fold f) (in (succ (in (succ (in zero)))))
=
  f (succ (f (fmap (fold f) (succ (in (succ (in zero)))))
=
  ...
=
  f (succ (f (succ (f (succ (f zero))))))

-}


map : forall a b. (a -> b) -> NatF a -> NatF b
map = \ f. case #'Zero (con #'Zero)
         | case #'Succ (o (con #'Succ) f)

fold : forall a. NatFAlg a -> Mu NatF -> a
fold = \a. fix (\rec x. a (map rec (out x)))

add' : Nat -> Nat -> Nat
add' = \m n. fold (\x. match (x : Sigma { 'Zero := Unit, 'Succ := Nat})
                       ( (case #'Zero (const m : Unit -> Nat)       : Sigma {'Zero := Unit} -> Nat)
                       | (case #'Succ ((\ih. succ ih) : Nat -> Nat) : Sigma {'Succ := Nat} -> Nat)) )  -- NatFAlg Nat  == NatF Nat -> Nat
                  n -- Mu NatF

add'' : Nat -> Nat -> Nat
add'' = \m. fold ( (case #'Zero (const m : Unit -> Nat) : Sigma {'Zero := Unit} -> Nat)
                 | (case #'Succ (succ : Nat -> Nat)     : Sigma {'Succ := Nat} -> Nat))
                   -- NatFAlg Nat  == NatF Nat -> Nat



x = add' 1 2
y = add' 3 4
