-------------------------------------------------------------------------------
-- Functions

o : forall t u v. (u -> v) -> (t -> u) -> t -> v
o = \ f g x. f (g x)

type Id : * -> *
type Id = \x. x

id : t -> t
id = \x. x

type Const : * -> * -> *
type Const = \x y. x

const : t -> u -> t
const = \ x y. x

flip : (a -> b -> c) -> b -> a -> c
flip = \ f b a. f a b

-------------------------------------------------------------------------------
-- Unit type

type Unit : *
type Unit = Pi {}

tt : Unit
tt = prj (#'x := /\ a. \x. x)

-------------------------------------------------------------------------------
-- the any label

any : forall l : L. #l
any = /\ l. #l

-------------------------------------------------------------------------------
-- Convenience functions for records and variants

-- sel : {l := t} < z => Pi z -> #l -> t
sel : Pi> {l := t} -> #l -> t
sel = \ r l. prj r / l

con : #l -> t -> Sigma> {l := t}
con = \l x. inj (l := x)

match : a -> (a -> b) -> b
match = \x f. f x

case : #l -> (t -> u) -> Sigma { l := t } -> u
case = \ l f x. f (x / l)

otherwise : a -> b -> a
otherwise = const

brnl : x < z => (Sigma x -> t) -> (Sigma z -> t) -> Sigma z -> t
brnl = \ f g. f | (g . inj)

relabelS : #l0 -> #l1 -> Sigma ({l0 := t} + z) -> Sigma ({l1 := t} + z)
relabelS = \ l0 l1. case l0 (con l1) | inj

relabelP : #l0 -> #l1 -> Pi ({l0 := t} + z) -> Pi ({l1 := t} + z)
relabelP = \ l0 l1 r. (l1 := r.l0) ++ prj r

---

type Labels : R[*] -> R[*]
type Labels = \r. Const Unit r

upd : Labels x' < Labels x => Pi x -> Pi (x' + y) -> Pi (x + y)
upd = \r s. r ++ prj s

--------------------------------------------------------------------------------
-- The Bool type

type Bool : *
type Bool = Sigma { 'True := Unit, 'False := Unit }

True : Bool
True = con #'True tt

False : Bool
False = con #'False tt

ite : Bool -> t -> t -> t
ite = 'True: u -> (\t1 t2. t1)
    | 'False: u ->  (\t1 t2. t2)

not : Bool -> Bool
not = \ b. ite b False True

and : Bool -> Bool -> Bool
and = \ b. ite b id (const False)

or : Bool -> Bool -> Bool
or = \ b. ite b (const True) id

--------------------------------------------------------------------------------
-- Bot elimination

impossible : Sigma {} -> a
impossible = fix (\x. x)

-------------------------------------------------------------------------------
-- Basic analysis / synthesis


reflect : forall z : R[*], t. Pi (z -> t) -> Sigma z -> t
reflect = \ d w. ana #(\X. X) (\ l u. d.l u) w

reify : forall z t. (Sigma z -> t) -> Pi (z -> t)
reify = /\ z t. \f. syn #(\X. X -> t) (\l x. f (l: x))

-- Categorical duals to reify / reflect. Don't have great names for these.
decompose : forall z : R[*] , t. Pi (t -> z) -> (t -> Pi z)
decompose = \ d t. syn #(\ X. X) (\ l. d.l t)

recompose : forall z : R[*] , t. (t -> Pi z) -> Pi (t -> z)
recompose = /\ z t. \ f. syn #(\ X. t -> X) (\ l u. sel (f u) l)

every : forall a : *, z : R[*]. a -> Pi (Const a z)
every = /\a. \x. syn #(\X. a) (\l. x)

type Eq : * -> *
type Eq = \t. t -> t -> Bool

eqS : forall z : R[*]. Pi (Eq z) -> Eq (Sigma z)
eqS = \ d v. ana #(\X. X)
                 (\ l y. match v
                         ( l: x -> d.l x y
                         | otherwise -> False))

eqP : forall z: R[*]. Fold z => Pi (Eq z) -> Eq (Pi z)
eqP = \ d r. fold (\l x. d.l r.l x) and True

-- Branching is derivable
branch : (Sigma x -> t) -> (Sigma y -> t) -> Sigma (x + y) -> t
branch = \ f g. reflect (reify f ++ reify g)

-------------------------------------------------------------------------------

eqUnit : Eq Unit
eqUnit = eqP tt

eqBool : Eq Bool
eqBool = eqS (every eqUnit)

-------------------------------------------------------------------------------

type Maybe : * -> *
type Maybe = \a. Sigma { 'Nothing := Unit, 'Just := a }

Just : a -> Maybe a
Just = 'Just:

Nothing : Maybe a
Nothing = 'Nothing: tt

maybe : b -> (a -> b) -> Maybe a -> b
maybe = \z f.
        ( 'Nothing: u -> z
        | 'Just: x -> f x
        )

is : {l := t} < z => #l -> Sigma z -> Maybe t
is = \ l. case l Just | otherwise Nothing

fromMaybe : a -> Maybe a -> a
fromMaybe = \z. maybe z id

-------------------------------------------------------------------------------

type Either : * -> * -> *
type Either = \a b. Sigma { 'Left := a, 'Right := b }

Left : forall a b. a -> Either a b
Left = \a. con #'Left a

Right : forall a b. b -> Either a b
Right = \b. con #'Right b

either : forall a b c. (a -> c) -> (b -> c) -> Either a b -> c
either = \ f g. (case #'Left f | case #'Right g)

-------------------------------------------------------------------------------

sorry : forall a. a
sorry = fix (\x. x)