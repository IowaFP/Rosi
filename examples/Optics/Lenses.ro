import Ro.Base , Ro.Show, Data.Tuple , Data.Nat , Data.List
{- 
-- reading list:

  # Bidirectional transformations
    - Introduction to BX
      - https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/ssbx-intro.pdf
    - Combinators for Bidirectional Tree Transformations: A Linguistic Approach to the View-Update Problem
      - https://dl.acm.org/doi/pdf/10.1145/1232420.1232424

  # Symmetric lenses & complements
    - Symmetric Lenses
      - https://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf 
    - Complements Witness Consistency
      - https://groups.inf.ed.ac.uk/bx/2016-Bx-CWC.pdf
  
  # Lenses *without* combinators
    - HOBiT: Programming Lenses Without Lens Combinators.
      This may be a promising avenue of Rosi if we can realize BX sans combinators
      - https://mengwangoxf.github.io/Papers/ESOP18.pdf

  # Profunctor optics & prisms
    - What you need to know about Yoneda:
      - https://www.cs.ox.ac.uk/jeremy.gibbons/publications/proyo.pdf
    - Profunctor Optics: Modular Data Accessors
      (fairly accessible and implementation oriented)
      - https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf

  # Dependent lenses
    - Secondary reading that may be relevant to dependent rows
      - https://www.cse.chalmers.se/~nad/publications/danielsson-dependent-lenses.pdf
      - https://www.cse.chalmers.se/~nad/publications/capriotti-danielsson-vezzosi-higher-lenses.pdf

-}
--------------------------------------------------------------------------------
-- to run (from home dir):
--   - cabal run Rosi -- -i rolib -i examples Optics.Lenses
-- to evaluate terms, e.g., showBob:
--   - cabal run Rosi -- -i rolib -i examples Optics.Lenses -e showBob

--------------------------------------------------------------------------------
-- The interface for lenses 
--
-- N.b. there are handful of equivalent representations one could use.
-- I follow the simplest and original, as proposed by Foster et al (2007).

-- Swapping the order or #l and (Pi z) from that in Ro.Base
sel : forall l t z. {l := t} < z => #l -> Pi z -> t
sel = \ l r. prj r / l

type Lens : * -> * -> *
type Lens =  \ s t. Pi { 'get := s -> t , 'put := s -> t -> s }

get : forall s t : *. Lens s t -> s -> t 
get = sel #'get 

put : forall s t : *. Lens s t -> s -> t -> s 
put = sel #'put

-- Each label forms a lens 
lens : forall l : L , t : * , z : R[*]. {l := t} < z => #l -> Lens (Pi z) t
lens = \ l. (#'get := sel l , #'put := \ s t. (l := t) ++ prj s)

-- lenses may be composed
comp : forall a b c : *. Lens a b -> Lens b c -> Lens a c 
comp = \ x y. (#'get :=  o (get y) (get x) , #'put := \ a c. put x a (put y (get x a) c) )


--------------------------------------------------------------------------------
-- An example nested record type

type Address : * 
type Address = Pi { 'street := String , 'zip := Nat }

type Place : * 
type Place = Pi { 'address := Address , 'isApartment := Bool  }

type Person : * 
type Person = Pi { 'age := Nat , 'place := Place }

--------------------------------------------------------------------------------
-- Bob, an example Person

Bob : Person
Bob = (#'age := 2 , 
       #'place := 
         (#'address     := (#'street := "Abbey Road" , #'zip := 1) ,
          #'isApartment := True))

--------------------------------------------------------------------------------
-- Pretty printing Bob

showAddress : Show Address
showAddress = showP (#'names := (#'street := "street" , #'zip := "zip") , #'shows := (#'street := id , #'zip := showNat))

showPlace : Show Place
showPlace = 
  showP (#'names := (#'address := "address" , #'isApartment := "isApartment") , 
         #'shows := (#'address := showAddress , #'isApartment := showBool))

showPerson : Show Person
showPerson = showP (#'names := (#'age := "age" , #'place := "place") , #'shows := (#'age := showNat , #'place := showPlace))

showBob : String
showBob = showPerson Bob

--------------------------------------------------------------------------------
-- Getting and updating Bob with lenses

streetLens : Lens Person String 
streetLens = comp (comp (lens #'place) (lens #'address)) (lens #'street)

-- Getting is straightforward
BobStreet : String
BobStreet = get streetLens Bob 

-- Updating is straightforward
movedBob : Person 
movedBob = put streetLens Bob "1818 Pleasant St."

-- N.b., evaluating `put` terms causes my compiler to loop.
-- To reproduce, run:
--   cabal run Rosi -- -i rolib -i examples Optics.Lenses -e bug
bug : Person 
bug = put (lens #'age) Bob 2

